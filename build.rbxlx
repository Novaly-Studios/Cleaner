<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX1A869F7AC88242D988C4D10F9D10D0BC">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBX797EFF02BF7546EF9C44C896EF51AD1F</Ref>
			<double name="DistributedGameTime">0</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsInertiaAndVolumeFix">0</token>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001de26</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX797EFF02BF7546EF9C44C896EF51AD1F">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>67.5873795</X>
					<Y>55.0748329</Y>
					<Z>-43.3989639</Z>
					<R00>0.698625982</R00>
					<R01>0.0443581119</R01>
					<R02>0.714110792</R02>
					<R10>-0</R10>
					<R11>0.998076439</R11>
					<R12>-0.0619970746</R12>
					<R20>-0.715487182</R20>
					<R21>0.0433127657</R21>
					<R22>0.697282076</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>66.1591721</X>
					<Y>55.1988258</Y>
					<Z>-44.7935143</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f79d</UniqueId>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX61CC111311144D4F870B71FA865B6F9F">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f816</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX68BED124E40B437EB981C6509AA042FF">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002c5f7</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBXFDE41E95C5E941CEB53B9FD374419D5D">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002c661</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Part" referent="RBX779B436C7E7C4E86BA976C0A46CFD294">
			<Properties>
				<bool name="Anchored">false</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002c7d2</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>4</X>
					<Y>1.20000005</Y>
					<Z>2</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXC974C768E6514BCFB4E703563473415E">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f751</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX20AD4E6B3BB74B329AB2A1E8FCBDB206">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f75d</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXAFD11A67A05645C18B26C867908E20F2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f75e</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXC3E309D1B5064AEC9D1D1D815EDAF1E0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f763</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBXAB3AECFDC8374FFA864B537DB2A600A2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f764</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX450B6250405E43DBA2328F1B04421D32">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f766</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f76a</UniqueId>
		</Properties>
		<Item class="ModuleScript" referent="1">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TypeGuard</string>
				<string name="ScriptGuid">{1474C894-7338-4908-B272-89D768635A9F}</string>
				<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["tpc9000_typeguard@1.2.0"]["typeguard"])
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f80f</UniqueId>
			</Properties>
		</Item>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">_Index</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f810</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXCC9AD262B5DC4A2EA2BF4228975CE2F1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">tpc9000_typeguard@1.2.0</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">376798fc9c6d206402b5dabd0002c09b</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX92F355460D8C491AB0A61F53C99D52E2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">typeguard</string>
						<string name="ScriptGuid">{FE24D655-79F9-4E39-838A-CE2915E0E433}</string>
						<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
-- @TODO This script really needs splitting up into sub-modules

local EMPTY_STRING = ""
local INVALID_ARGUMENT = "Invalid argument #%s (%s expected, got %s)"

-- Cache up here so these arrays aren't re-created with every function call for the simple checking system
local EXPECT_TABLE = {"table"}
local EXPECT_STRING = {"string"}
local EXPECT_FUNCTION = {"function"}
local EXPECT_SOMETHING = {"something"}
local EXPECT_TABLE_OR_FUNCTION = {"table", "function"}
local EXPECT_NUMBER_OR_FUNCTION = {"number", "function"}
local EXPECT_STRING_OR_FUNCTION = {"string", "function"}
local EXPECT_INSTANCE_OR_FUNCTION = {"Instance", "function"}
local EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION = {"Enum", "EnumItem", "function"}

--- This is only really for type checking internally for data passed to constraints and util functions
local function ExpectType<T>(PassedArg: T, ExpectedTypes: {string}, ArgKey: number | string)
    local GotType = typeof(PassedArg)
    local Satisfied = false

    for _, PossibleType in ipairs(ExpectedTypes) do
        if (GotType == PossibleType) then
            Satisfied = true
            break
        end
    end

    assert(Satisfied, INVALID_ARGUMENT:format(tostring(ArgKey), table.concat(ExpectedTypes, " or "), GotType))
end

local function CreateStandardInitial(ExpectedTypeName: string): ((...any) -> (boolean, string))
    return function(_, Item)
        local ItemType = typeof(Item)

        if (ItemType == ExpectedTypeName) then
            return true, EMPTY_STRING
        end

        return false, "Expected " .. ExpectedTypeName .. ", got " .. ItemType
    end
end

local function ConcatWithToString<T>(Array: {T}, Separator: string): string
    local Result = EMPTY_STRING
    local Size = #Array

    for Index, Value in ipairs(Array) do
        Result ..= tostring(Value)

        if (Index < Size) then
            Result ..= Separator
        end
    end

    return Result
end

local STRUCTURE_TO_FLAT_STRING_MT = {
    __tostring = function(self)
        local Pairings = {}

        for Key, Value in pairs(self) do
            table.insert(Pairings, tostring(Key) .. " = " .. tostring(Value))
        end

        return "{" .. ConcatWithToString(Pairings, ", ") .. "}"
    end;
}

-- Standard re-usable functions throughout all TypeCheckers
    local function IsAKeyIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAKeyIn", function(_, Key, Store)
            return Store[Key] ~= nil, "No key found in table: " .. tostring(Store)
        end, Store)
    end

    local function IsAValueIn(self, Store)
        ExpectType(Store, EXPECT_TABLE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAValueIn", function(_, TargetValue, Store)
            for _, Value in pairs(Store) do
                if (Value == TargetValue) then
                    return true, EMPTY_STRING
                end
            end

            return false, "No value found in table: " .. tostring(Store)
        end, Store)
    end

    local function Equals(self, ExpectedValue)
        return self:_AddConstraint("Equals", function(_, Value, ExpectedValue)
            return Value == ExpectedValue, "Value " .. tostring(Value) .. " does not equal " .. tostring(ExpectedValue)
        end, ExpectedValue)
    end

    local function GreaterThan(self, GTValue)
        return self:_AddConstraint("GreaterThan", function(_, Value, GTValue)
            return Value > GTValue, "Value " .. tostring(Value) .. " is not greater than " .. tostring(GTValue)
        end, GTValue)
    end

    local function LessThan(self, LTValue)
        return self:_AddConstraint("LessThan", function(_, Value, LTValue)
            return Value < LTValue, "Value " .. tostring(Value) .. " is not less than " .. tostring(LTValue)
        end, LTValue)
    end

    local function GreaterThanOrEqualTo(self, GTEValue)
        return self:_AddConstraint("GreaterThanOrEqualTo", function(_, Value, GTEValue)
            return Value >= GTEValue, "Value " .. tostring(Value) .. " is not greater than or equal to " .. tostring(GTEValue)
        end, GTEValue)
    end

    local function LessThanOrEqualTo(self, LTEValue)
        return self:_AddConstraint("LessThanOrEqualTo", function(_, Value, LTEValue)
            return Value <= LTEValue, "Value " .. tostring(Value) .. " is not less than or equal to " .. tostring(LTEValue)
        end, LTEValue)
    end




type SelfReturn<T, P...> = ((T, P...) -> T)

type TypeCheckerConstructor<T, P...> = ((P...) -> T)

type TypeChecker<T> = {
    Or: SelfReturn<T, TypeChecker<any> | () -> TypeChecker<any>>;
    And: SelfReturn<T, TypeChecker<any>>;
    Alias: SelfReturn<T, string>;
    Negate: SelfReturn<T>;
    Optional: SelfReturn<T>;
    WithContext: SelfReturn<T, any?>;

    _AddTag: SelfReturn<T, string>;

    WrapCheck: (T) -> ((any) -> (boolean, string));
    WrapAssert: (T) -> ((any) -> ());
    Check: (T, any) -> (string, boolean);
    Assert: (T, any) -> ();

    -- Standard constraints
    Equals: SelfReturn<T, any>;
    equals: SelfReturn<T, any>;

    IsAValueIn: SelfReturn<T, any>;
    isAValueIn: SelfReturn<T, any>;

    IsAKeyIn: SelfReturn<T, any>;
    isAKeyIn: SelfReturn<T, any>;

    GreaterThan: SelfReturn<T, number | (any?) -> number>;
    greaterThan: SelfReturn<T, number | (any?) -> number>;

    LessThan: SelfReturn<T, number | (any?) -> number>;
    lessThan: SelfReturn<T, number | (any?) -> number>;

    GreaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    greaterThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;

    LessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
    lessThanOrEqualTo: SelfReturn<T, number | (any?) -> number>;
};

local RootContext -- Faster & easier just using one high scope variable which all TypeCheckers can access during checking time, than propogating the context downwards
local TypeGuard = {}

-- Needs refactoring, there should be a different way to self-reference in future
function TypeGuard.FindFirstParent(TypeName: string)
    local Found = nil

    return function(self)
        if (Found) then
            return Found
        end

        while (true) do
            self = self._LastParent

            if (self == nil) then
                error("No parent found for type " .. TypeName)
            end

            if (self.Type == TypeName) then
                Found = self
                return Found
            end
        end
    end
end

--- Creates a template TypeChecker object that can be used to extend behaviors via constraints
function TypeGuard.Template(Name: string)
    ExpectType(Name, EXPECT_STRING, 1)

    local TemplateClass = {}
    TemplateClass.__index = TemplateClass
    TemplateClass._InitialConstraints = nil
    TemplateClass._InitialConstraint = nil
    TemplateClass.IsTemplate = true
    TemplateClass.Type = Name

    function TemplateClass.new(...)
        local self = {
            _Tags = {};
            _Disjunction = {};
            _Conjunction = {};
            _ActiveConstraints = {};

            _LastConstraint = EMPTY_STRING;

            _Context = nil;
            _LastParent = nil;
        }

        setmetatable(self, TemplateClass)

        local NumArgs = select("#", ...)

        -- Support for a single constraint passed as the constructor, with an arbitrary number of args
        local InitialConstraint = self._InitialConstraint

        if (InitialConstraint and NumArgs > 0) then
            return InitialConstraint(self, ...)
        end

        -- Multiple constraints support (but only ONE arg per constraint is supported currently)
        local InitialConstraints = TemplateClass._InitialConstraints

        if (InitialConstraints and NumArgs > 0) then
            for Index = 1, NumArgs do
                self = InitialConstraints[Index](self, select(Index, ...))
            end

            return self
        end

        return self
    end

    function TemplateClass:Copy()
        local New = TemplateClass.new()

        -- Copy tags
        for Key, Value in pairs(self._Tags) do
            New._Tags[Key] = Value
        end

        -- Copy OR
        for Index, Disjunction in ipairs(self._Disjunction) do
            New._Disjunction[Index] = Disjunction
        end

        -- Copy AND
        for Index, Conjunction in ipairs(self._Conjunction) do
            New._Conjunction[Index] = Conjunction
        end

        -- Copy constraints
        for ConstraintName, Constraint in pairs(self._ActiveConstraints) do
            New._ActiveConstraints[ConstraintName] = Constraint
        end

        New._Context = self._Context
        New._LastParent = self._LastParent
        New._LastConstraint = self._LastConstraint

        return New
    end

    --- Wraps & negates the last constraint (i.e. if it originally would fail, it passes, and vice versa)
    function TemplateClass:Negate()
        self = self:Copy()

        local LastConstraint = self._LastConstraint
        assert(LastConstraint ~= EMPTY_STRING, "Nothing to negate! (No constraints active)")
        self._ActiveConstraints[LastConstraint][4] = true

        return self
    end

    function TemplateClass:_AddConstraint(ConstraintName, Constraint, ...)
        ExpectType(ConstraintName, EXPECT_STRING, 1)
        ExpectType(Constraint, EXPECT_FUNCTION, 2)

        self = self:Copy()
        self._LastConstraint = ConstraintName

        local Args = {...}
        local HasFunctions = false

        -- Establish parent reference in the children & check for any functions
        for _, Value in ipairs(Args) do
            local ArgType = typeof(Value)

            if (ArgType == "function") then
                HasFunctions = true
                continue
            end

            if (ArgType == "table" and Value.IsTemplate) then
                Value._LastParent = self
            end
        end

        local ActiveConstraints = self._ActiveConstraints
        assert(ActiveConstraints[ConstraintName] == nil, "Constraint already exists: " .. ConstraintName)
        ActiveConstraints[ConstraintName] = {Constraint, Args, HasFunctions, false}
        return self
    end

    --- Calling this will only check the type of the passed value if that value is not nil, i.e. it's an optional value so nothing can be passed, but if it is not nothing then it will be checked
    function TemplateClass:Optional()
        return self:_AddTag("Optional")
    end

    --- Enqueues a new constraint to satisfy 'or' i.e. "check x or check y or check z or ..." must pass
    function TemplateClass:Or(OtherType)
        if (typeof(OtherType) ~= "function") then
            TypeGuard._AssertIsTypeBase(OtherType, 1)
            OtherType._LastParent = self._LastParent
        end

        self = self:Copy()
        table.insert(self._Disjunction, OtherType)
        return self
    end

    --- Enqueues a new constraint to satisfy 'and' i.e. "check x and check y and check z and ..." must pass
    function TemplateClass:And(OtherType)
        TypeGuard._AssertIsTypeBase(OtherType, 1)
        OtherType._LastParent = self._LastParent

        self = self:Copy()
        table.insert(self._Conjunction, OtherType)
        return self
    end

    --- Creates an Alias - useful for replacing large "Or" chains in big structures to identify where it is failing
    function TemplateClass:Alias(AliasName)
        ExpectType(AliasName, EXPECT_STRING, 1)

        self = self:Copy()
        self._Alias = AliasName
        return self
    end

    --- Adds a tag (for internal purposes)
    function TemplateClass:_AddTag(TagName)
        ExpectType(TagName, EXPECT_STRING, 1)
        assert(self._Tags[TagName] == nil, "Tag already exists: " .. TagName)

        self = self:Copy()
        self._Tags[TagName] = true
        return self
    end

    --- Passes down a "context" value to constraints with functional values
    --- We don't copy here because performance is important at the checking phase
    function TemplateClass:WithContext(Context)
        --self = self:Copy()
        self._Context = Context
        return self
    end

    --- Wrap Check into its own callable function
    function TemplateClass:WrapCheck()
        return function(Value)
            return self:_Check(Value)
        end
    end

    --- Wraps Assert into its own callable function
    function TemplateClass:WrapAssert()
        return function(Value)
            return self:Assert(Value)
        end
    end

    --- Checks if the value is of the correct type
    function TemplateClass:_Check(Value)
        -- Handle "type x or type y or type z ..."
        -- We do this before checking constraints to check if any of the other conditions succeed
        local Disjunctions = self._Disjunction
        local DidTryDisjunction = (Disjunctions[1] ~= nil)

        for _, AlternateType in ipairs(Disjunctions) do
            if (typeof(AlternateType) == "function") then
                AlternateType = AlternateType(self)
            end

            local Success, _ = AlternateType:_Check(Value, RootContext)

            if (Success) then
                return true, EMPTY_STRING
            end
        end

        -- Handle "type x and type y and type z ..." - this is only really useful for objects and arrays
        for _, Conjunction in ipairs(self._Conjunction) do
            local Success, Message = Conjunction:_Check(Value, RootContext)

            if (not Success) then
                return false, "[Conjunction " .. tostring(Conjunction) .. "] " .. Message
            end
        end

        -- Optional allows the value to be nil, in which case it won't be checked and we can resolve
        if (self._Tags.Optional and Value == nil) then
            return true, EMPTY_STRING
        end

        -- Handle initial type check
        local Success, Message = self:_Initial(Value)

        if (not Success) then
            if (DidTryDisjunction) then
                return false, "Disjunctions failed on " .. tostring(self)
            else
                return false, Message
            end
        end

        -- Handle active constraints
        for ConstraintName, Constraint in pairs(self._ActiveConstraints) do
            local Call = Constraint[1]
            local Args = Constraint[2]
            local HasFunctionalParams = Constraint[3]
            local ShouldNegate = Constraint[4]

            -- Functional params -> transform into values when type checking
            if (HasFunctionalParams) then
                Args = table.clone(Args)

                for Index, Arg in ipairs(Args) do
                    if (typeof(Arg) == "function") then
                        Args[Index] = Arg(RootContext)
                    end
                end
            end

            -- Call the constraint to verify it is satisfied
            local SubSuccess, SubMessage = Call(self, Value, unpack(Args))

            if (ShouldNegate) then
                SubMessage = if (SubSuccess) then
                                "Constraint '" .. ConstraintName .. "' succeeded but was expected to fail on value " .. tostring(Value)
                             else
                                EMPTY_STRING

                SubSuccess = not SubSuccess
            end

            if (not SubSuccess) then
                if (DidTryDisjunction) then
                    return false, "Disjunctions failed on " .. tostring(self)
                else
                    return false, SubMessage
                end
            end
        end

        return true, EMPTY_STRING
    end

    --- Check (like above) except sets a universal context for the duration of the check
    function TemplateClass:Check(Value)
        RootContext = self._Context
        local Success, Result = self:_Check(Value)
        RootContext = nil
        return Success, Result
    end

    --- Throws an error if the check is unsatisfied
    function TemplateClass:Assert(Value)
        assert(self:Check(Value))
    end

    function TemplateClass:__tostring()
        -- User can create a unique alias to help simplify "where did it fail?"
        if (self._Alias) then
            return self._Alias
        end

        local Fields = {}

        -- Constraints list (including arg, possibly other type defs)
        if (next(self._ActiveConstraints) ~= nil) then
            local InnerConstraints = {}

            for ConstraintName, Constraint in pairs(self._ActiveConstraints) do
                table.insert(InnerConstraints, ConstraintName .. "(" .. ConcatWithToString(Constraint[2], ", ") .. ")")
            end

            table.insert(Fields, "Constraints = {" .. ConcatWithToString(InnerConstraints, ", ") .. "}")
        end

        -- Alternatives field str
        if (#self._Disjunction > 0) then
            local Alternatives = {}

            for _, AlternateType in ipairs(self._Disjunction) do
                table.insert(Alternatives, tostring(AlternateType))
            end

            table.insert(Fields, "Or = {" .. ConcatWithToString(Alternatives, ", ") .. "}")
        end

        -- Union fields str
        if (#self._Conjunction > 0) then
            local Unions = {}

            for _, Union in ipairs(self._Conjunction) do
                table.insert(Unions, tostring(Union))
            end

            table.insert(Fields, "And = {" .. ConcatWithToString(Unions, ", ") .. "}")
        end

        -- Tags (e.g. Optional, Strict)
        if (next(self._Tags) ~= nil) then
            local Tags = {}

            for Tag in pairs(self._Tags) do
                table.insert(Tags, Tag)
            end

            table.insert(Fields, "Tags = {" .. ConcatWithToString(Tags, ", ") .. "}")
        end

        if (self._Context) then
            table.insert(Fields, "Context = " .. tostring(self._Context))
        end

        return self.Type .. "(" .. ConcatWithToString(Fields, ", ") .. ")"
    end

    TemplateClass.Equals = Equals
    TemplateClass.equals = Equals

    TemplateClass.IsAValueIn = IsAValueIn
    TemplateClass.isAValueIn = IsAValueIn

    TemplateClass.IsAKeyIn = IsAKeyIn
    TemplateClass.isAKeyIn = IsAKeyIn

    TemplateClass.GreaterThan = GreaterThan
    TemplateClass.greaterThan = GreaterThan

    TemplateClass.LessThan = LessThan
    TemplateClass.lessThan = LessThan

    TemplateClass.GreaterThanOrEqualTo = GreaterThanOrEqualTo
    TemplateClass.greaterThanOrEqualTo = GreaterThanOrEqualTo

    TemplateClass.LessThanOrEqualTo = LessThanOrEqualTo
    TemplateClass.lessThanOrEqualTo = LessThanOrEqualTo

    return function(...)
        return TemplateClass.new(...)
    end, TemplateClass
end

--- Checks if an object contains the fields which define a type template from this module
function TypeGuard._AssertIsTypeBase<T>(Subject: T, Position: number | string)
    ExpectType(Subject, EXPECT_TABLE, Position)

    assert(Subject.IsTemplate, "Subject is not a type template")
end

--- Cheap & easy way to create a type without any constraints, and just an initial check corresponding to Roblox's typeof
function TypeGuard.FromTypeName(TypeName: string)
    ExpectType(TypeName, EXPECT_STRING, 1)

    local CheckerFunction, CheckerClass = TypeGuard.Template(TypeName)
    CheckerClass._Initial = CreateStandardInitial(TypeName)

    type CustomTypeChecker = TypeChecker<CustomTypeChecker> & {}
    return CheckerFunction :: TypeCheckerConstructor<CustomTypeChecker>
end
TypeGuard.fromTypeName = TypeGuard.FromTypeName




do
    type NumberTypeChecker = TypeChecker<NumberTypeChecker> & {
        Integer: SelfReturn<NumberTypeChecker>;
        integer: SelfReturn<NumberTypeChecker>;

        Decimal: SelfReturn<NumberTypeChecker>;
        decimal: SelfReturn<NumberTypeChecker>;

        RangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeInclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        RangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;
        rangeExclusive: SelfReturn<NumberTypeChecker, number | (any?) -> number, number | (any?) -> number>;

        Positive: SelfReturn<NumberTypeChecker>;
        positive: SelfReturn<NumberTypeChecker>;

        Negative: SelfReturn<NumberTypeChecker>;
        negative: SelfReturn<NumberTypeChecker>;
    };

    local Number: TypeCheckerConstructor<NumberTypeChecker, TypeChecker<any>?>, NumberClass = TypeGuard.Template("Number")
    NumberClass._Initial = CreateStandardInitial("number")

    --- Checks if the value is whole
    function NumberClass:Integer()
        return self:_AddConstraint("Integer", function(_, Item)
            if (Item % 1 == 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected integer form, got " .. tostring(Item)
        end)
    end
    NumberClass.integer = NumberClass.Integer

    --- Checks if the number is a decimal
    function NumberClass:Decimal()
        return self:_AddConstraint("Decimal", function(_, Item)
            if (Item % 1 ~= 0) then
                return true, EMPTY_STRING
            end

            return false, "Expected decimal form, got " .. tostring(Item)
        end)
    end
    NumberClass.decimal = NumberClass.Decimal

    --- Ensures a number is between or equal to a minimum and maxmimu value
    function NumberClass:RangeInclusive(Min, Max)
        ExpectType(Min, EXPECT_NUMBER_OR_FUNCTION, 1)
        ExpectType(Max, EXPECT_NUMBER_OR_FUNCTION, 2)

        return self:GreaterThanOrEqualTo(Min):LessThanOrEqualTo(Max)
    end
    NumberClass.rangeInclusive = NumberClass.RangeInclusive

    --- Ensures a number is between but not equal to a minimum and maximum value
    function NumberClass:RangeExclusive(Min, Max)
        return self:GreaterThan(Min):LessThan(Max)
    end
    NumberClass.rangeExclusive = NumberClass.RangeExclusive

    --- Checks the number is positive
    function NumberClass:Positive()
        return self:_AddConstraint("Positive", function(_, Item)
            if (Item < 0) then
                return false, "Expected positive number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.positive = NumberClass.Positive

    --- Checks the number is negative
    function NumberClass:Negative()
        return self:_AddConstraint("Negative", function(_, Item)
            if (Item >= 0) then
                return false, "Expected negative number, got " .. tostring(Item)
            end

            return true, EMPTY_STRING
        end)
    end
    NumberClass.negative = NumberClass.Negative

    TypeGuard.Number = Number
    TypeGuard.number = Number
end




do
    type StringTypeChecker = TypeChecker<StringTypeChecker> & {
        MinLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<StringTypeChecker, number | (any?) -> number>;

        Pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        pattern: SelfReturn<StringTypeChecker, string | (any?) -> string>;

        Contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
        contains: SelfReturn<StringTypeChecker, string | (any?) -> string>;
    };

    local String: TypeCheckerConstructor<StringTypeChecker, TypeChecker<any>?>, StringClass = TypeGuard.Template("String")
    StringClass._Initial = CreateStandardInitial("string")

    --- Ensures a string is at least a certain length
    function StringClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, Item, MinLength)
            if (#Item < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    StringClass.minLength = StringClass.MinLength

    --- Ensures a string is at most a certain length
    function StringClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, Item, MaxLength)
            if (#Item > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #Item
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    StringClass.maxLength = StringClass.MaxLength

    --- Ensures a string matches a pattern
    function StringClass:Pattern(PatternString)
        ExpectType(PatternString, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Pattern", function(_, Item, Pattern)
            if (string.match(Item, Pattern) ~= Item) then
                return false, "String does not match pattern " .. tostring(Pattern)
            end

            return true, EMPTY_STRING
        end, PatternString)
    end
    StringClass.pattern = StringClass.Pattern

    --- Ensures a string contains a certain substring
    function StringClass:Contains(SubstringValue)
        ExpectType(SubstringValue, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("Contains", function(_, Item, Substring)
            if (string.find(Item, Substring) == nil) then
                return false, "String does not contain substring " .. tostring(Substring)
            end

            return true, EMPTY_STRING
        end, SubstringValue)
    end

    TypeGuard.String = String
    TypeGuard.string = String
end




do
    local PREFIX_ARRAY = "Index "
    local PREFIX_PARAM = "Param #"
    local ERR_PREFIX = "[%s%d] "
    local ERR_UNEXPECTED_VALUE = ERR_PREFIX .. " Unexpected value (strict tag is present)"

    type ArrayTypeChecker = TypeChecker<ArrayTypeChecker> & {
        OfLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        ofLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MinLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        minLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        MaxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;
        maxLength: SelfReturn<ArrayTypeChecker, number | (any?) -> number>;

        Contains: SelfReturn<ArrayTypeChecker, any>;
        contains: SelfReturn<ArrayTypeChecker, any>;

        OfType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;
        ofType: SelfReturn<ArrayTypeChecker, TypeChecker<any>>;

        OfStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        ofStructure: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;
        structuralEquals: SelfReturn<ArrayTypeChecker, {TypeChecker<any>}>;

        Strict: SelfReturn<ArrayTypeChecker>;
        strict: SelfReturn<ArrayTypeChecker>;

        DenoteParams: SelfReturn<ArrayTypeChecker>;
        denoteParams: SelfReturn<ArrayTypeChecker>;
    };

    local Array: TypeCheckerConstructor<ArrayTypeChecker, TypeChecker<any>?>, ArrayClass = TypeGuard.Template("Array")

    function ArrayClass:_PrefixError(ErrorString: string, Index: number)
        return ErrorString:format((self._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), Index)
    end

    function ArrayClass:_Initial(TargetArray)
        if (typeof(TargetArray) ~= "table") then
            return false, "Expected table, got " .. typeof(TargetArray)
        end

        for Key in pairs(TargetArray) do
            local KeyType = typeof(Key)

            if (KeyType ~= "number") then
                return false, "Non-numetic key detected: " .. KeyType
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures an array is of a certain length
    function ArrayClass:OfLength(Length)
        ExpectType(Length, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("Length", function(_, TargetArray, Length)
            if (#TargetArray ~= Length) then
                return false, "Length must be " .. Length .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, Length)
    end
    ArrayClass.ofLength = ArrayClass.OfLength

    --- Ensures an array is at least a certain length
    function ArrayClass:MinLength(MinLength)
        ExpectType(MinLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MinLength", function(_, TargetArray, MinLength)
            if (#TargetArray < MinLength) then
                return false, "Length must be at least " .. MinLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MinLength)
    end
    ArrayClass.minLength = ArrayClass.MinLength

    --- Ensures an array is at most a certain length
    function ArrayClass:MaxLength(MaxLength)
        ExpectType(MaxLength, EXPECT_NUMBER_OR_FUNCTION, 1)

        return self:_AddConstraint("MaxLength", function(_, TargetArray, MaxLength)
            if (#TargetArray > MaxLength) then
                return false, "Length must be at most " .. MaxLength .. ", got " .. #TargetArray
            end

            return true, EMPTY_STRING
        end, MaxLength)
    end
    ArrayClass.maxLength = ArrayClass.MaxLength

    --- Ensures an array contains some given value
    function ArrayClass:Contains(Value, StartPoint)
        if (Value == nil) then
            ExpectType(Value, EXPECT_SOMETHING, 1)
        end

        if (StartPoint) then
            ExpectType(StartPoint, EXPECT_NUMBER_OR_FUNCTION, 2)
        end

        return self:_AddConstraint("Contains", function(_, TargetArray, Value, StartPoint)
            if (table.find(TargetArray, Value, StartPoint) == nil) then
                return false, "Value not found in array: " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, Value, StartPoint)
    end
    ArrayClass.contains = ArrayClass.Contains

    --- Ensures each value in the template array satisfies the passed TypeChecker
    function ArrayClass:OfType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfType", function(SelfRef, TargetArray, SubType)
            for Index, Value in ipairs(TargetArray) do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, ERR_PREFIX:format((SelfRef._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), tostring(Index)) .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ArrayClass.ofType = ArrayClass.OfType

    -- Takes an array of types and checks it against the passed array
    function ArrayClass:OfStructure(SubTypesAtPositions)
        ExpectType(SubTypesAtPositions, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = table.create(#SubTypesAtPositions)

        for Index, Value in ipairs(SubTypesAtPositions) do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, TargetArray, SubTypesAtPositions)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Index, Checker in ipairs(SubTypesAtPositions) do
                local Success, SubMessage = Checker:_Check(TargetArray[Index])

                if (not Success) then
                    return false, SelfRef:_PrefixError(ERR_PREFIX, tostring(Index)) .. SubMessage
                end
            end

            -- Check there are no extra indexes which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Index in ipairs(TargetArray) do
                    local Checker = SubTypesAtPositions[Index]

                    if (not Checker) then
                        return false, SelfRef:_PrefixError(ERR_UNEXPECTED_VALUE, tostring(Index))
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy, SubTypesAtPositions)
    end
    ArrayClass.ofStructure = ArrayClass.OfStructure

    --- OfStructure but strict
    function ArrayClass:StructuralEquals(Other)
        return self:OfStructure(Other):Strict()
    end
    ArrayClass.structuralEquals = ArrayClass.StructuralEquals

    --- Tags this ArrayTypeChecker as strict i.e. no extra indexes allowed in OfStructure constraint
    function ArrayClass:Strict()
        return self:_AddTag("Strict")
    end
    ArrayClass.strict = ArrayClass.Strict

    --- Tags this ArrayTypeChecker as a params call (just for better information when using TypeGuard.Params)
    function ArrayClass:DenoteParams()
        return self:_AddTag("DenoteParams")
    end
    ArrayClass.denoteParams = ArrayClass.DenoteParams

    ArrayClass._InitialConstraint = ArrayClass.OfType

    TypeGuard.Array = Array
end




do
    type ObjectTypeChecker = TypeChecker<ObjectTypeChecker> & {
        OfStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        ofStructure: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        StructuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;
        structuralEquals: SelfReturn<ObjectTypeChecker, {[any]: TypeChecker<any>}>;

        Strict: SelfReturn<ObjectTypeChecker>;
        strict: SelfReturn<ObjectTypeChecker>;

        OfValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofValueType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;

        OfKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
        ofKeyType: SelfReturn<ObjectTypeChecker, TypeChecker<any>>;
    };

    local Object: TypeCheckerConstructor<ObjectTypeChecker, {[any]: TypeChecker<any>}?>, ObjectClass = TypeGuard.Template("Object")

    function ObjectClass:_Initial(TargetObject)
        if (typeof(TargetObject) ~= "table") then
            return false, "Expected table, got " .. typeof(TargetObject)
        end

        for Key in pairs(TargetObject) do
            if (typeof(Key) == "number") then
                return false, "Incorrect key type: number"
            end
        end

        return true, EMPTY_STRING
    end

    --- Ensures every key that exists in the subject also exists in the structure passed, optionally strict i.e. no extra key-value pairs
    function ObjectClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Index, Value in pairs(OriginalSubTypes) do
            TypeGuard._AssertIsTypeBase(Value, Index)
            SubTypesCopy[Index] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, StructureCopy, SubTypes)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Key, Checker in pairs(SubTypes) do
                local RespectiveValue = StructureCopy[Key]

                if (RespectiveValue == nil and not Checker._Tags.Optional) then
                    return false, "[Key '" .. tostring(Key) .. "'] is nil"
                end

                local Success, SubMessage = Checker:_Check(RespectiveValue)

                if (not Success) then
                    return false, "[Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra fields which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Key in pairs(StructureCopy) do
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Key '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    ObjectClass.ofStructure = ObjectClass.OfStructure

    --- For all values in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfValueType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfValueType", function(_, TargetArray, SubType)
            for Index, Value in pairs(TargetArray) do
                local Success, SubMessage = SubType:_Check(Value)

                if (not Success) then
                    return false, "[OfValueType: Key '" .. tostring(Index) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofValueType = ObjectClass.OfValueType

    --- For all keys in the passed table, they must satisfy the TypeChecker passed to this constraint
    function ObjectClass:OfKeyType(SubType)
        TypeGuard._AssertIsTypeBase(SubType, 1)

        return self:_AddConstraint("OfKeyType", function(_, TargetArray, SubType)
            for Key in pairs(TargetArray) do
                local Success, SubMessage = SubType:_Check(Key)

                if (not Success) then
                    return false, "[OfKeyType: Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, SubType)
    end
    ObjectClass.ofKeyType = ObjectClass.OfKeyType

    --- Strict i.e. no extra key-value pairs than what is explicitly specified when using OfStructure
    function ObjectClass:Strict()
        return self:_AddTag("Strict")
    end
    ObjectClass.strict = ObjectClass.Strict

    --- OfStructure but strict
    function ObjectClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    ObjectClass.structuralEquals = ObjectClass.StructuralEquals

    ObjectClass._InitialConstraint = ObjectClass.OfStructure

    TypeGuard.Object = Object
end




do
    type InstanceTypeChecker = TypeChecker<InstanceTypeChecker> & {
        OfStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        ofStructure: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        StructuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;
        structuralEquals: SelfReturn<InstanceTypeChecker, {[any]: TypeChecker<Instance>}>;

        IsA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        isA: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        Strict: SelfReturn<InstanceTypeChecker>;
        strict: SelfReturn<InstanceTypeChecker>;

        HasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;
        hasTag: SelfReturn<InstanceTypeChecker, string | (any?) -> string>;

        IsDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isDescendantOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;

        IsAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
        isAncestorOf: SelfReturn<InstanceTypeChecker, Instance | (any?) -> Instance>;
    };

    local function Get(Inst, Key)
        return Inst[Key]
    end

    local function TryGet(Inst, Key)
        local Success, Result = pcall(Get, Inst, Key)

        if (Success) then
            return Result
        end

        return nil
    end

    local InstanceChecker: TypeCheckerConstructor<InstanceTypeChecker, string | (any?) -> string | nil, {[string]: TypeChecker<any>}?>, InstanceCheckerClass = TypeGuard.Template("Instance")
    InstanceCheckerClass._Initial = CreateStandardInitial("Instance")

    --- Ensures that an Instance has specific children and/or properties
    function InstanceCheckerClass:OfStructure(OriginalSubTypes)
        ExpectType(OriginalSubTypes, EXPECT_TABLE, 1)

        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in pairs(OriginalSubTypes) do
            TypeGuard._AssertIsTypeBase(Value, Key)
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, InstanceRoot, SubTypes)
            -- Check all properties and children which should be in the Instance exist (unless optional) and the type check for each passes
            for Key, Checker in pairs(SubTypes) do
                local Value = TryGet(InstanceRoot, Key)
                local Success, SubMessage = Checker:_Check(Value)

                if (not Success) then
                    return false, (typeof(Value) == "Instance" and "[Instance '" or "[Property '") .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra children which shouldn't be in the Instance
            if (SelfRef._Tags.Strict) then
                for _, Value in ipairs(InstanceRoot:GetChildren()) do
                    local Key = Value.Name
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Instance '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    InstanceCheckerClass.ofStructure = InstanceCheckerClass.OfStructure

    --- Uses Instance.IsA to assert the type of an Instance
    function InstanceCheckerClass:IsA(InstanceIsA)
        ExpectType(InstanceIsA, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, InstanceRoot, InstanceIsA)
            if (not InstanceRoot:IsA(InstanceIsA)) then
                return false, "Expected " .. InstanceIsA .. ", got " .. InstanceRoot.ClassName
            end

            return true, EMPTY_STRING
        end, InstanceIsA)
    end
    InstanceCheckerClass.isA = InstanceCheckerClass.IsA

    --- Activates strict tag for OfStructure
    function InstanceCheckerClass:Strict()
        return self:_AddTag("Strict")
    end
    InstanceCheckerClass.strict = InstanceCheckerClass.Strict

    --- OfStructure + strict tag i.e. no extra children exist beyond what is specified
    function InstanceCheckerClass:StructuralEquals(Structure)
        return self:OfStructure(Structure):Strict()
    end
    InstanceCheckerClass.structuralEquals = InstanceCheckerClass.StructuralEquals

    --- Checks if an Instance has a particular tag
    function InstanceCheckerClass:HasTag(Tag: string)
        ExpectType(Tag, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasTag", function(_, InstanceRoot, Tag)
            if (CollectionService:HasTag(InstanceRoot, Tag)) then
                return true, EMPTY_STRING
            end

            return false, "Expected tag '" .. Tag .. "' on Instance " .. InstanceRoot:GetFullName()
        end, Tag)
    end

    --- Checks if an Instance is a descendant of a particular Instance
    function InstanceCheckerClass:IsDescendantOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsDescendantOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsDescendantOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be a descendant of " .. Instance:GetFullName()
        end, Instance)
    end

    --- Checks if an Instance is an ancestor of a particular Instance
    function InstanceCheckerClass:IsAncestorOf(Instance)
        ExpectType(Instance, EXPECT_INSTANCE_OR_FUNCTION, 1)

        return self:_AddConstraint("IsAncestorOf", function(_, SubjectInstance, Instance)
            if (SubjectInstance:IsAncestorOf(Instance)) then
                return true, EMPTY_STRING
            end

            return false, "Expected Instance " .. SubjectInstance:GetFullName() .. " to be an ancestor of " .. Instance:GetFullName()
        end, Instance)
    end

    InstanceCheckerClass._InitialConstraints = {InstanceCheckerClass.IsA, InstanceCheckerClass.OfStructure}

    TypeGuard.Instance = InstanceChecker
end




do
    type BooleanTypeChecker = TypeChecker<BooleanTypeChecker> & {};

    local Boolean: TypeCheckerConstructor<BooleanTypeChecker, boolean?>, BooleanClass = TypeGuard.Template("Boolean")
    BooleanClass._Initial = CreateStandardInitial("boolean")

    BooleanClass._InitialConstraint = BooleanClass.Equals

    TypeGuard.Boolean = Boolean
    TypeGuard.boolean = Boolean
end




do
    type EnumTypeChecker = TypeChecker<EnumTypeChecker> & {
        IsA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
        isA: SelfReturn<EnumTypeChecker, Enum | EnumItem | (any?) -> Enum | EnumItem>;
    };

    local EnumChecker: TypeCheckerConstructor<EnumTypeChecker>, EnumCheckerClass = TypeGuard.Template("Enum")

    function EnumCheckerClass:_Initial(Value)
        local GotType = typeof(Value)

        if (GotType ~= "EnumItem" and GotType ~= "Enum") then
            return false, "Expected EnumItem or Enum, got " .. GotType
        end

        return true, EMPTY_STRING
    end

    --- Ensures that a passed EnumItem is either equivalent to an EnumItem or a sub-item of an Enum class
    function EnumCheckerClass:IsA(TargetEnum)
        ExpectType(TargetEnum, EXPECT_ENUM_OR_ENUM_ITEM_OR_FUNCTION, 1)

        return self:_AddConstraint("IsA", function(_, Value, TargetEnum)
            local TargetType = typeof(TargetEnum)

            -- Both are EnumItems
            if (TargetType == "EnumItem") then
                if (Value == TargetEnum) then
                    return true, EMPTY_STRING
                end

                return false, "Expected " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            -- TargetType is an Enum
            if (table.find(TargetEnum:GetEnumItems(), Value) == nil) then
                return false, "Expected a " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            return true, EMPTY_STRING
        end, TargetEnum)
    end
    EnumCheckerClass.isA = EnumCheckerClass.IsA

    EnumCheckerClass._InitialConstraint = EnumCheckerClass.IsA

    TypeGuard.Enum = EnumChecker
end




do
    type NilTypeChecker = TypeChecker<NilTypeChecker> & {};

    local NilChecker: TypeCheckerConstructor<NilTypeChecker>, NilCheckerClass = TypeGuard.Template("Nil")

    function NilCheckerClass:_Initial(Value)
        if (Value == nil) then
            return true, EMPTY_STRING
        end

        return false, "Expected nil, got " .. typeof(Value)
    end

    TypeGuard.Nil = NilChecker
    TypeGuard["nil"] = NilChecker
end




do
    type ThreadTypeChecker = TypeChecker<ThreadTypeChecker> & {
        IsDead: SelfReturn<ThreadTypeChecker>;
        isDead: SelfReturn<ThreadTypeChecker>;

        IsSuspended: SelfReturn<ThreadTypeChecker>;
        isSuspended: SelfReturn<ThreadTypeChecker>;

        IsRunning: SelfReturn<ThreadTypeChecker>;
        isRunning: SelfReturn<ThreadTypeChecker>;

        IsNormal: SelfReturn<ThreadTypeChecker>;
        isNormal: SelfReturn<ThreadTypeChecker>;

        HasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
        hasStatus: SelfReturn<ThreadTypeChecker, string | (any?) -> string>;
    };

    local ThreadChecker: TypeCheckerConstructor<ThreadTypeChecker>, ThreadCheckerClass = TypeGuard.Template("Thread")
    ThreadCheckerClass._Initial = CreateStandardInitial("thread")

    function ThreadCheckerClass:IsDead()
        return self:HasStatus("dead"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsSuspended()
        return self:HasStatus("suspended"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsRunning()
        return self:HasStatus("running"):_AddTag("StatusCheck")
    end

    function ThreadCheckerClass:IsNormal()
        return self:HasStatus("normal"):_AddTag("StatusCheck")
    end

    --- Checks the coroutine's status against a given status string
    function ThreadCheckerClass:HasStatus(Status)
        ExpectType(Status, EXPECT_STRING_OR_FUNCTION, 1)

        return self:_AddConstraint("HasStatus", function(_, Thread, Status)
            local CurrentStatus = coroutine.status(Thread)

            if (CurrentStatus == Status) then
                return true, EMPTY_STRING
            end

            return false, "Expected thread to have status '" .. Status .. "', got " .. CurrentStatus
        end, Status)
    end

    TypeGuard._InitialConstraint = ThreadCheckerClass.HasStatus

    TypeGuard.Thread = ThreadChecker
    TypeGuard.thread = ThreadChecker
end



-- Luau data types
TypeGuard.Axes = TypeGuard.FromTypeName("Axes")
TypeGuard.BrickColor = TypeGuard.FromTypeName("BrickColor")
TypeGuard.CatalogSearchParams = TypeGuard.FromTypeName("CatalogSearchParams")
TypeGuard.CFrame = TypeGuard.FromTypeName("CFrame")
TypeGuard.Color3 = TypeGuard.FromTypeName("Color3")
TypeGuard.ColorSequence = TypeGuard.FromTypeName("ColorSequence")
TypeGuard.ColorSequenceKeypoint = TypeGuard.FromTypeName("ColorSequenceKeypoint")
TypeGuard.DateTime = TypeGuard.FromTypeName("DateTime")
TypeGuard.DockWidgetPluginGuiInfo = TypeGuard.FromTypeName("DockWidgetPluginGuiInfo")
TypeGuard.Enums = TypeGuard.FromTypeName("Enums")
TypeGuard.Faces = TypeGuard.FromTypeName("Faces")
TypeGuard.FloatCurveKey = TypeGuard.FromTypeName("FloatCurveKey")
TypeGuard.NumberRange = TypeGuard.FromTypeName("NumberRange")
TypeGuard.NumberSequence = TypeGuard.FromTypeName("NumberSequence")
TypeGuard.NumberSequenceKeypoint = TypeGuard.FromTypeName("NumberSequenceKeypoint")
TypeGuard.OverlapParams = TypeGuard.FromTypeName("OverlapParams")
TypeGuard.PathWaypoint = TypeGuard.FromTypeName("PathWaypoint")
TypeGuard.PhysicalProperties = TypeGuard.FromTypeName("PhysicalProperties")
TypeGuard.Random = TypeGuard.FromTypeName("Random")
TypeGuard.Ray = TypeGuard.FromTypeName("Ray")
TypeGuard.RaycastParams = TypeGuard.FromTypeName("RaycastParams")
TypeGuard.RaycastResult = TypeGuard.FromTypeName("RaycastResult")
TypeGuard.RBXScriptConnection = TypeGuard.FromTypeName("RBXScriptConnection")
TypeGuard.RBXScriptSignal = TypeGuard.FromTypeName("RBXScriptSignal")
TypeGuard.Rect = TypeGuard.FromTypeName("Rect")
TypeGuard.Region3 = TypeGuard.FromTypeName("Region3")
TypeGuard.Region3int16 = TypeGuard.FromTypeName("Region3int16")
TypeGuard.TweenInfo = TypeGuard.FromTypeName("TweenInfo")
TypeGuard.UDim = TypeGuard.FromTypeName("UDim")
TypeGuard.UDim2 = TypeGuard.FromTypeName("UDim2")
TypeGuard.Vector2 = TypeGuard.FromTypeName("Vector2")
TypeGuard.Vector2int16 = TypeGuard.FromTypeName("Vector2int16")
TypeGuard.Vector3 = TypeGuard.FromTypeName("Vector3")
TypeGuard.Vector3int16 = TypeGuard.FromTypeName("Vector3int16")

-- Extra base Lua data types
TypeGuard.Function = TypeGuard.FromTypeName("function")
TypeGuard["function"] = TypeGuard.Function

TypeGuard.Userdata = TypeGuard.FromTypeName("userdata")
TypeGuard["userdata"] = TypeGuard.Userdata

--- Creates a function which checks params as if they were a strict Array checker
function TypeGuard.Params(...: TypeChecker<any>)
    local Params = {...}

    for Index, ParamChecker in ipairs(Params) do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    local Checker = TypeGuard.Array():StructuralEquals(Params):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.params = TypeGuard.Params

--- Creates a function which checks variadic params against a single given TypeChecker
function TypeGuard.VariadicParams(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    local Checker = TypeGuard.Array():OfType(CompareType):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.variadicParams = TypeGuard.VariadicParams


--- Creates a function which checks params as if they were a strict Array checker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.ParamsWithContext(...: TypeChecker<any>)
    local Params = {...}

    for Index, ParamChecker in ipairs(Params) do
        TypeGuard._AssertIsTypeBase(ParamChecker, Index)
    end

    local Checker = TypeGuard.Array():StructuralEquals(Params):DenoteParams()

    return function(Context: any?, ...)
        Checker:WithContext(Context):Assert({...})
    end
end

--- Creates a function which checks variadic params against a single given TypeChecker, using context as the first param; context is passed down to functional constraint args
function TypeGuard.VariadicParamsWithContext(CompareType: TypeChecker<any>)
    TypeGuard._AssertIsTypeBase(CompareType, 1)

    local Checker = TypeGuard.Array():OfType(CompareType):DenoteParams()

    return function(Context: any?, ...)
        Checker:WithContext(Context):Assert({...})
    end
end

--- Wraps a function in a param checker function
function TypeGuard.WrapFunctionParams<T>(Call: T, ...: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)

    for Index = 1, select("#", ...) do
        TypeGuard._AssertIsTypeBase(select(Index, ...), Index)
    end

    local ParamChecker = TypeGuard.Params(...)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

--- Wraps a function in a variadic param checker function
function TypeGuard.WrapFunctionVariadicParams<T>(Call: T, VariadicParamType: TypeChecker<any>)
    ExpectType(Call, EXPECT_FUNCTION, 1)
    TypeGuard._AssertIsTypeBase(VariadicParamType, 2)

    local ParamChecker = TypeGuard.VariadicParams(VariadicParamType)

    return function(...)
        ParamChecker(...)
        return Call(...)
    end
end

return TypeGuard]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">376798fc9c6d206402b5dabd0002c09c</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXE9CAB992957B4AB1B0E5613081DBD785">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TypeGuard.spec</string>
							<string name="ScriptGuid">{CC3B0473-BBFD-496A-BB72-90EB18AF1C38}</string>
							<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
-- TODO: finish off functional input tests
-- TODO: Negate() tests
-- TODO: turn Or, And into constraints?

return function()
    local TypeGuard = require(script.Parent)

    describe("Template", function()
        it("should reject no Name given", function()
            expect(function()
                TypeGuard.Template()
            end).to.throw()
        end)

        it("should reject incorrect types for Name", function()
            expect(function()
                TypeGuard.Template(1)
            end).to.throw()

            expect(function()
                TypeGuard.Template({})
            end).to.throw()

            expect(function()
                TypeGuard.Template(true)
            end).to.throw()

            expect(function()
                TypeGuard.Template("Test")
            end).never.to.throw()
        end)

        it("should return a constructor function and a TypeChecker class for extension", function()
            local TestCreate, TestClass = TypeGuard.Template("Test")
            expect(TestCreate).to.be.a("function")
            expect(TestClass).to.be.a("table")
            expect(TestClass.IsTemplate).to.equal(true)
        end)
    end)

    describe("Params", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.Params(1)
            end).to.throw()

            expect(function()
                TypeGuard.Params({})
            end).to.throw()

            expect(function()
                TypeGuard.Params(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.Params(TypeGuard.Number(), TypeGuard.String())(1, 1)
            end).to.throw()
        end)
    end)

    describe("ParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())("Test", 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1)
            end).never.to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, "Test")
            end).never.to.throw()

            expect(function()
                TypeGuard.ParamsWithContext(TypeGuard.Number(), TypeGuard.String())(nil, 1, 1)
            end).to.throw()
        end)
    end)

    describe("VariadicParams", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParams(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())("Test")
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParams(TypeGuard.Number())(1, "Test")
            end).to.throw()
        end)
    end)

    describe("VariadicParamsWithContext", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(1)
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext({})
            end).to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should check one type", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, "Test")
            end).to.throw()
        end)

        it("should accept a context as first arg (or nil)", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())("Test", 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1, 1)
            end).never.to.throw()
        end)

        it("should pass the context down", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number():Equals(function(Context)
                    return Context.MustEqual
                end))({MustEqual = 1}, 1, 1, 2)
            end).to.throw()
        end)

        it("should check multiple types", function()
            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, 1)
            end).never.to.throw()

            expect(function()
                TypeGuard.VariadicParamsWithContext(TypeGuard.Number())(nil, 1, "Test")
            end).to.throw()
        end)
    end)

    describe("WrapFunctionParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end)
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, _Y, _Z) end

            local TestWrapped = TypeGuard.WrapFunctionParams(TestFunction, TypeGuard.Number(), TypeGuard.String(), TypeGuard.Boolean())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1, "x", true)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x", "y")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true, "y")
            end).to.throw()

            expect(function()
                TestWrapped("1", "x", true)
            end).to.throw()
        end)
    end)

    describe("WrapFunctionVariadicParams", function()
        it("should reject non functions as first arg", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams({})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(true)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()
        end)

        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, 1)
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, {})
            end).to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Number())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.String())
            end).never.to.throw()

            expect(function()
                TypeGuard.WrapFunctionVariadicParams(function() end, TypeGuard.Array())
            end).never.to.throw()
        end)

        it("should wrap a function", function()
            local function TestFunction(_X, ...) end

            local TestWrapped = TypeGuard.WrapFunctionVariadicParams(TestFunction, TypeGuard.Number())
            expect(TestWrapped).to.be.a("function")

            expect(function()
                TestWrapped(1)
            end).never.to.throw()

            expect(function()
                TestWrapped(1, "x")
            end).to.throw()

            expect(function()
                TestWrapped(1, "x", true)
            end).to.throw()

            expect(function()
                TestWrapped(9, 8, 7, 6, 5, 4, 3, 2, 1)
            end).never.to.throw()
        end)
    end)

    -- These behaviors extend to all TypeChecker implementations
    describe("TypeChecker", function()
        describe("Optional", function()
            it("should accept nil as a checked value", function()
                expect(TypeGuard.Number():Optional():Check(nil)).to.equal(true)
            end)

            it("should accept the target constraint as a checked value if not nil", function()
                expect(TypeGuard.Number():Optional():Check(1)).to.equal(true)
                expect(TypeGuard.Number():Optional():Check("Test")).to.equal(false)
            end)
        end)

        describe("Alias", function()
            it("should reject non-string args", function()
                expect(function()
                    TypeGuard.Number():Alias(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Alias(true)
                end).to.throw()
            end)

            it("should accept string args", function()
                expect(function()
                    TypeGuard.Number():Alias("Test")
                end).never.to.throw()
            end)

            it("should give a fail string with the alias", function()
                local _, Result = TypeGuard.Number():Or(TypeGuard.Array()):Alias("TestAlias"):Check("Test")
                expect(Result).to.be.a("string")
                expect(Result:match("TestAlias")).to.be.ok()
            end)
        end)

        describe("Or", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():Or(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():Or(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should accept function args", function()
                expect(function()
                    TypeGuard.Number():Or(function() end)
                end).never.to.throw()
            end)

            it("should accept inputs if they satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject inputs if they do not satisfy a TypeChecker in the or chain", function()
                local Check = TypeGuard.Number():Or(TypeGuard.Boolean())
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)

            it("should accept functional inputs if they return a TypeChecker which satisfies the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(true)).to.equal(true)
                expect(Check:Check(false)).to.equal(true)
            end)

            it("should reject functional inputs if they return a TypeChecker which does not satisfy the or chain", function()
                local Check = TypeGuard.Number():Or(function() return TypeGuard.Boolean() end)
                expect(Check:Check("Test")).to.equal(false)
                expect(Check:Check({})).to.equal(false)
            end)

            it("should allow self-references with functional or", function()
                local CleanableChecker = TypeGuard.Array():OfType(
                    TypeGuard.RBXScriptConnection()
                    :Or(TypeGuard.Instance())
                    :Or(TypeGuard.FindFirstParent("Array"))
                )

                expect(CleanableChecker:Check({
                    [1] = Instance.new("Model");
                    [2] = Instance.new("Part").ChildAdded:Connect(function() end);
                    [3] = {
                        [1] = Instance.new("Folder");
                        [2] = Instance.new("Folder");
                        [3] = Instance.new("Folder");
                        [4] = {};
                        [5] = {
                            [1] = Instance.new("Folder");
                        };
                    };
                })).to.equal(true)

                expect(CleanableChecker:Check({
                    [1] = Instance.new("Model");
                    [2] = Instance.new("Part").ChildAdded:Connect(function() end);
                    [3] = {
                        [1] = Instance.new("Folder");
                        [2] = Instance.new("Folder");
                        [3] = Instance.new("Folder");
                        [4] = {};
                        [5] = {
                            [1] = 1;
                        };
                    };
                })).to.equal(false)
            end)
        end)

        describe("And", function()
            it("should reject non-TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And({})
                end).to.throw()

                expect(function()
                    TypeGuard.Number():And(true)
                end).to.throw()
            end)

            it("should accept TypeChecker args", function()
                expect(function()
                    TypeGuard.Number():And(TypeGuard.Number())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.String())
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():And(TypeGuard.Array())
                end).never.to.throw()
            end)

            it("should reject inputs if they do not satisfy at least one TypeChecker in the and chain", function()
                local Check = TypeGuard.Number():And(TypeGuard.Boolean())
                expect(Check:Check(1)).to.equal(false)
                expect(Check:Check(true)).to.equal(false)
                expect(Check:Check(false)).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for objects)", function()
                local Check = TypeGuard.Object():OfStructure({X = TypeGuard.Number()})
                                :And(TypeGuard.Object():OfStructure({Y = TypeGuard.String()}))
                                :And(TypeGuard.Object():OfStructure({Z = TypeGuard.Boolean()}))

                expect(Check:Check({X = 1, Y = "A", Z = false})).to.equal(true)
                expect(Check:Check({X = 1})).to.equal(false)
                expect(Check:Check({X = 1, Y = "A", Z = {}})).to.equal(false)
            end)

            it("should accept inputs if they satisfy all TypeCheckers in the and chain and reject if they do not (for Instances)", function()
                local Check = TypeGuard.Instance():OfStructure({Name = TypeGuard.String()})
                              :And(TypeGuard.Instance():OfStructure({
                                  SomeChild = TypeGuard.Instance();
                              }))

                local TestInstance = Instance.new("Folder")
                    local SomeChild = Instance.new("Folder")
                    SomeChild.Name = "SomeChild"
                    SomeChild.Parent = TestInstance

                local TestInstance2 = Instance.new("Folder")
                    local SomeChild2 = Instance.new("Folder")
                    SomeChild2.Name = "SomeChild2"
                    SomeChild2.Parent = TestInstance2

                expect(Check:Check(TestInstance)).to.equal(true)
                expect(Check:Check(TestInstance2)).to.equal(false)
            end)
        end)

        describe("Check", function()
            it("should return a true boolean and an empty string on success", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")
            end)

            it("should return a false boolean and a fail string on failure", function()
                local Check = TypeGuard.Number()
                local Result, Error = Check:Check("Test")
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(false)
                expect(Error).to.be.a("string")
                expect(Error).never.to.equal("")
            end)
        end)
        describe("WrapCheck", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapCheck()).to.be.a("function")
            end)

            it("should call Check directly and pass a boolean & status string", function()
                local Check = TypeGuard.Number():WrapCheck()
                local Result, Error = Check(1)
                expect(Result).to.be.a("boolean")
                expect(Result).to.equal(true)
                expect(Error).to.be.a("string")
                expect(Error).to.equal("")

                local Result2, Error2 = Check("Test")
                expect(Result2).to.be.a("boolean")
                expect(Result2).to.equal(false)
                expect(Error2).to.be.a("string")
                expect(Error2).never.to.equal("")
            end)
        end)

        describe("Assert", function()
            it("should not throw when the type is satisfied", function()
                expect(function()
                    TypeGuard.Number():Assert(1)
                end).never.to.throw()
            end)

            it("should throw when the type is unsatisfied, giving the status string", function()
                local Input = "Test"
                local _, CheckResult = TypeGuard.Number():Check(Input)

                expect(function()
                    TypeGuard.Number():Assert(Input)
                end).to.throw(CheckResult)
            end)
        end)

        describe("WrapAssert", function()
            it("should return a function", function()
                expect(TypeGuard.Number():WrapAssert()).to.be.a("function")
            end)

            it("should call Assert directly and pass a boolean & status string", function()
                local Input = 1

                local _, CheckResult = TypeGuard.Number():Check(Input)
                local AssertFunction = TypeGuard.Number():WrapAssert()

                expect(function()
                    AssertFunction(Input)
                end).never.to.throw()

                expect(function()
                    AssertFunction("Test")
                end).to.throw(CheckResult)
            end)
        end)

        describe("Negate", function()
            it("should throw an exception if there are no constraints", function()
                expect(function()
                    TypeGuard.Number():Negate()
                end).to.throw()
            end)

            it("should invert the result of the TypeChecker", function()
                local Check = TypeGuard.Number():Equals(5):Negate()
                expect(Check:Check(1)).to.equal(true)
                expect(Check:Check(5)).to.equal(false)
                expect(Check:Check(10)).to.equal(true)
            end)

            it("should invert only the last constraint", function()
                local Check = TypeGuard.Number():GreaterThan(1):Equals(10):Negate()
                expect(Check:Check(2)).to.equal(true)
                expect(Check:Check(10)).to.equal(false)
                expect(Check:Check(20)).to.equal(true)
            end)
        end)

        describe("WithContext", function()
            it("should accept any value", function()
                expect(function()
                    TypeGuard.Number():WithContext("Test")
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(1)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(true)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(false)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(nil)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext(Instance.new("Folder"))
                end).never.to.throw()

                expect(function()
                    TypeGuard.Number():WithContext({X = 1, Y = 2})
                end).never.to.throw()
            end)

            it("should pass the context to constraints", function()
                local DidRun = false
                local Check = TypeGuard.Number():WithContext("Test"):Equals(function(Context)
                    DidRun = true
                    expect(Context).to.equal("Test")
                    return 1
                end)

                expect(Check:Check(1)).to.equal(true)
                expect(DidRun).to.equal(true)
            end)

            it("should pass the root context down even if a new context is given mid-way", function()
                local DidRun = false
                local Check = TypeGuard.Object():WithContext("Test0"):OfStructure({
                    X = TypeGuard.Object():WithContext("Test1"):OfStructure({
                        Y = TypeGuard.Number():WithContext("Test2"):Equals(function(Context)
                            DidRun = true
                            expect(Context).to.equal("Test0")
                            return 1
                        end)
                    });
                })

                expect(Check:Check({
                    X = {
                        Y = 1;
                    }
                })).to.equal(true)
                expect(DidRun).to.equal(true)
            end)
        end)
    end)

    describe("Number", function()
        local Base = TypeGuard.Number()

        describe("Init", function()
            it("should reject non-numbers", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(true)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept numbers", function()
                expect(Base:Check(1)).to.equal(true)
                expect(Base:Check(1.1)).to.equal(true)
                expect(Base:Check(0)).to.equal(true)
                expect(Base:Check(-1)).to.equal(true)
                expect(Base:Check(-1.1)).to.equal(true)
            end)
        end)

        describe("Integer", function()
            it("should reject non-integers", function()
                expect(Base:Integer():Check(1.1)).to.equal(false)
            end)

            it("should accept integers", function()
                expect(Base:Integer():Check(1)).to.equal(true)
            end)

            it("should accept negative integers", function()
                expect(Base:Integer():Check(-1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Integer():Check("Test")).to.equal(false)
            end)
        end)

        describe("Decimal", function()
            it("should reject non-decimals", function()
                expect(Base:Decimal():Check(1)).to.equal(false)
            end)

            it("should accept decimals", function()
                expect(Base:Decimal():Check(1.1)).to.equal(true)
            end)

            it("should accept negative decimals", function()
                expect(Base:Decimal():Check(-1.1)).to.equal(true)
            end)

            it("should reject non-numbers", function()
                expect(Base:Decimal():Check("Test")).to.equal(false)
            end)
        end)

        describe("RangeInclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeInclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(0)).to.equal(false)
                expect(Range:Check(3)).to.equal(false)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                local Range = Base:RangeInclusive(1, 2)
                expect(Range:Check(1)).to.equal(true)
                expect(Range:Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(2)).to.equal(true)
            end)

            it("should accept numbers equal to the range bounds", function()
                expect(Base:RangeInclusive(1, 2):Check(1)).to.equal(true)
                expect(Base:RangeInclusive(1, 2):Check(2)).to.equal(true)

                local FuncRange = Base:RangeInclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(true)
                expect(FuncRange:Check(2)).to.equal(true)
            end)
        end)

        describe("RangeExclusive", function()
            it("should reject non-numbers", function()
                expect(Base:RangeExclusive(1, 2):Check("Test")).to.equal(false)
            end)

            it("should reject numbers outside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(0)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(3)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(0)).to.equal(false)
                expect(FuncRange:Check(3)).to.equal(false)
            end)

            it("should accept numbers inside of range", function()
                expect(Base:RangeExclusive(1, 2):Check(1.1)).to.equal(true)
                expect(Base:RangeExclusive(1, 2):Check(1.9)).to.equal(true)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1.1)).to.equal(true)
                expect(FuncRange:Check(1.9)).to.equal(true)
            end)

            it("should reject numbers equal to the range bounds", function()
                expect(Base:RangeExclusive(1, 2):Check(1)).to.equal(false)
                expect(Base:RangeExclusive(1, 2):Check(2)).to.equal(false)

                local FuncRange = Base:RangeExclusive(function()
                    return 1
                end, function()
                    return 2
                end)
                expect(FuncRange:Check(1)).to.equal(false)
                expect(FuncRange:Check(2)).to.equal(false)
            end)
        end)

        describe("Positive", function()
            it("should reject non-numbers", function()
                expect(Base:Positive():Check("Test")).to.equal(false)
            end)

            it("should reject negative numbers", function()
                expect(Base:Positive():Check(-1)).to.equal(false)
            end)

            it("should accept positive numbers", function()
                expect(Base:Positive():Check(0)).to.equal(true)
                expect(Base:Positive():Check(1)).to.equal(true)
            end)
        end)

        describe("Negative", function()
            it("should reject non-numbers", function()
                expect(Base:Negative():Check("Test")).to.equal(false)
            end)

            it("should reject positive numbers", function()
                expect(Base:Negative():Check(0)).to.equal(false)
                expect(Base:Negative():Check(1)).to.equal(false)
            end)

            it("should accept negative numbers", function()
                expect(Base:Negative():Check(-1)).to.equal(true)
            end)
        end)

        describe("Equals", function()
            it("should reject non equal inputs", function()
                expect(Base:Equals(1):Check(2)).to.equal(false)
                expect(Base:Equals(function()
                    return 1
                end):Check(2)).to.equal(false)
            end)

            it("should accept equal inputs", function()
                expect(Base:Equals(1):Check(1)).to.equal(true)
                expect(Base:Equals(function()
                    return 1
                end):Check(1)).to.equal(true)
            end)
        end)

        describe("GreaterThan", function()
            it("should reject numbers less than the first arg", function()
                expect(Base:GreaterThan(1):Check(0)).to.equal(false)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(1)).to.equal(false)
            end)

            it("should accept numbers greater than the first arg", function()
                expect(Base:GreaterThan(1):Check(2)).to.equal(true)
                expect(Base:GreaterThan(function()
                    return 1
                end):Check(2)).to.equal(true)
            end)
        end)

        describe("IsAKeyIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAKeyIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAKeyIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAKeyIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAKeyIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist as a key", function()
                expect(Base:IsAKeyIn({}):Check(123)).to.equal(false)
                expect(Base:IsAKeyIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value does exist as a key", function()
                expect(Base:IsAKeyIn({[123] = true}):Check(123)).to.equal(true)
                expect(Base:IsAKeyIn(function()
                    return {[123] = true}
                end):Check(123)).to.equal(true)
            end)
        end)

        describe("IsAValueIn", function()
            it("should reject a non table as first arg", function()
                expect(function()
                    Base:IsAValueIn(1)
                end).to.throw()

                expect(function()
                    Base:IsAValueIn("Test")
                end).to.throw()

                expect(function()
                    Base:IsAValueIn(true)
                end).to.throw()
            end)

            it("should accept a table or function as first arg", function()
                expect(function()
                    Base:IsAValueIn({})
                end).never.to.throw()

                expect(function()
                    Base:IsAValueIn(function() end)
                end).never.to.throw()
            end)

            it("should reject when the value does not exist in an array", function()
                expect(Base:IsAValueIn({}):Check(123)).to.equal(false)
                expect(Base:IsAValueIn(function()
                    return {}
                end):Check(123)).to.equal(false)
            end)

            it("should accept when the value exists in an array", function()
                expect(Base:IsAValueIn({123}):Check(123)).to.equal(true)
                expect(Base:IsAValueIn(function()
                    return {123}
                end):Check(123)).to.equal(true)
            end)
        end)
    end)

    describe("Boolean", function()
        local Base = TypeGuard.Boolean()

        describe("Init", function()
            it("should reject non-booleans", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept booleans", function()
                expect(Base:Check(true)).to.equal(true)
                expect(Base:Check(false)).to.equal(true)
            end)
        end)
    end)

    describe("Instance", function()
        local Base = TypeGuard.Instance()

        describe("Init", function()
            it("should reject non-Instances", function()
                expect(Base:Check("Test")).to.equal(false)
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept Instances", function()
                expect(Base:Check(Instance.new("Model"))).to.equal(true)
            end)

            it("should use the IsA constraint as the initial constraint", function()
                local Test = TypeGuard.Instance("Model")

                expect(Test:Check(Instance.new("Model"))).to.equal(true)
                expect(Test:Check(Instance.new("Part"))).to.equal(false)
            end)

            it("should use the IsA constraint + the OfStructure constraint if two values are passed", function()
                local Test = TypeGuard.Instance("Model", {
                    Name = TypeGuard.String():Equals("TestName");
                })

                expect(Test:Check(Instance.new("Model"))).to.equal(false)

                local Sample = Instance.new("Model")
                Sample.Name = "TestName"

                expect(Test:Check(Sample)).to.equal(true)
            end)
        end)

        describe("IsA", function()
            it("should reject non-Instances", function()
                expect(Base:IsA("Folder"):Check("Folder")).to.equal(false)
                expect(Base:IsA("Folder"):Check(1)).to.equal(false)
                expect(Base:IsA("Folder"):Check(function() end)).to.equal(false)
                expect(Base:IsA("Folder"):Check(nil)).to.equal(false)
                expect(Base:IsA("Folder"):Check({})).to.equal(false)
            end)

            it("should accept Instances of the specified type string (or function returning type string)", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Folder"))).to.equal(true)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Folder"))).to.equal(true)
            end)

            it("should reject Instances of other classes", function()
                expect(Base:IsA("Folder"):Check(Instance.new("Part"))).to.equal(false)
                expect(Base:IsA(function()
                    return "Folder"
                end):Check(Instance.new("Part"))).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should reject non-Instances", function()
                expect(function()
                    Base:OfStructure({Test = "Test"})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = 1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({Test = function() end})
                end).to.throw()
            end)

            it("should accept a map of children and/or properties", function()
                expect(function()
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    })
                end).to.never.throw()
            end)

            it("should reject Instances that do not match the structure", function()
                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(Instance.new("Folder"))
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder");
                        Name = TypeGuard.String();
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject Instances that do not match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Incorrect Name");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)

            it("should accept Instances that match the structure recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Part", Test)
                        Test2.Name = "Test2"

                expect(
                    Base:OfStructure({
                        Test = TypeGuard.Instance("Folder"):OfStructure({
                            Test2 = TypeGuard.Instance():OfStructure({
                                Name = TypeGuard.String():Equals("Test2");
                            });
                            Name = TypeGuard.String():Equals("Test");
                        });
                        Name = TypeGuard.String():Equals("Folder");
                    }):Check(Test)
                ).to.equal(false)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject extra flat children", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                    local Test2 = Instance.new("Folder", SampleTree)
                    Test2.Name = "Test2"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder");
                        Test2 = TypeGuard.Instance("Folder");
                    }):Check(SampleTree)
                ).to.equal(true)
            end)

            it("should reject extra children recursively", function()
                local SampleTree = Instance.new("Folder")
                    local Test = Instance.new("Folder", SampleTree)
                    Test.Name = "Test"
                        local Test2 = Instance.new("Folder", Test)
                        Test2.Name = "Test2"
                        local Test22 = Instance.new("Folder", Test)
                        Test22.Name = "Test22"

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            -- No Test22, should reject
                        });
                    }):Check(SampleTree)
                ).to.equal(false)

                expect(
                    Base:StructuralEquals({
                        Test = TypeGuard.Instance("Folder"):StructuralEquals({
                            Test2 = TypeGuard.Instance("Folder");
                            Test22 = TypeGuard.Instance("Folder");
                        });
                    }):Check(SampleTree)
                ).to.equal(true)
            end)
        end)

        describe("HasTag", function()
            it("should reject non-Instances", function()
                expect(Base:HasTag("Test"):Check("Test")).to.equal(false)
                expect(Base:HasTag("Test"):Check(1)).to.equal(false)
                expect(Base:HasTag("Test"):Check(function() end)).to.equal(false)
                expect(Base:HasTag("Test"):Check(nil)).to.equal(false)
                expect(Base:HasTag("Test"):Check({})).to.equal(false)
            end)

            it("should accept Instances with the specified tag", function()
                local Test = Instance.new("Folder")
                CollectionService:AddTag(Test, "TestTag")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(true)
            end)

            it("should reject Instances without the specified tag", function()
                local Test = Instance.new("Folder")
                expect(TypeGuard.Instance():HasTag("TestTag"):Check(Test)).to.equal(false)
                expect(TypeGuard.Instance():HasTag(function()
                    return "TestTag"
                end):Check(Test)).to.equal(false)
            end)
        end)

        describe("IsAncestorOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsAncestorOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are ancestors of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsAncestorOf(Test2):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(Test3):Check(Test)).to.equal(true)

                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test2
                end):Check(Test)).to.equal(true)
                expect(TypeGuard.Instance():IsAncestorOf(function()
                    return Test3
                end):Check(Test)).to.equal(true)
            end)
        end)

        describe("IsDescendantOf", function()
            it("should reject non-Instances", function()
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check("Test")).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(1)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(function() end)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check(nil)).to.equal(false)
                expect(Base:IsDescendantOf(Instance.new("Folder")):Check({})).to.equal(false)
            end)

            it("should accept Instances that are descendants of the specified Instance", function()
                local Test = Instance.new("Folder")
                local Test2 = Instance.new("Folder", Test)
                local Test3 = Instance.new("Folder", Test2)

                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(Test):Check(Test3)).to.equal(true)

                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test2)).to.equal(true)
                expect(TypeGuard.Instance():IsDescendantOf(function()
                    return Test
                end):Check(Test3)).to.equal(true)
            end)
        end)
    end)

    describe("String", function()
        local Base = TypeGuard.String()

        describe("Init", function()
            it("should accept a string", function()
                expect(Base:Check("Test")).to.equal(true)
            end)

            it("should reject non-strings", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject strings shorter than the specified length", function()
                expect(Base:MinLength(5):Check("Test")).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test")).to.equal(false)
            end)

            it("should accept strings longer than the specified length", function()
                expect(Base:MinLength(5):Check("Test123")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("Test123")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MinLength(5):Check("12345")).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject strings longer than the specified length", function()
                expect(Base:MaxLength(5):Check("Test123")).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test123")).to.equal(false)
            end)

            it("should accept strings shorter than the specified length", function()
                expect(Base:MaxLength(5):Check("Test")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("Test")).to.equal(true)
            end)

            it("should accept strings equal to the specified length", function()
                expect(Base:MaxLength(5):Check("12345")).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check("12345")).to.equal(true)
            end)
        end)

        describe("Pattern", function()
            it("should accept strings matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("34789275")).to.equal(true)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("34789275")).to.equal(true)
            end)

            it("should reject strings not matching the specified pattern", function()
                expect(Base:Pattern("[0-9]+"):Check("123h4")).to.equal(false)
                expect(Base:Pattern(function()
                    return "[0-9]+"
                end):Check("123h4")).to.equal(false)
            end)
        end)

        describe("Contains", function()
            it("should accept strings containing the specified substring", function()
                expect(Base:Contains("Test"):Check("------Test123")).to.equal(true)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("------Test123")).to.equal(true)
            end)

            it("should reject strings not containing the specified substring", function()
                expect(Base:Contains("Test"):Check("asdfghjkl")).to.equal(false)
                expect(Base:Contains(function()
                    return "Test"
                end):Check("asdfghjkl")).to.equal(false)
            end)
        end)
    end)

    describe("Array", function()
        local Base = TypeGuard.Array()

        describe("Init", function()
            it("should accept an array", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({1})).to.equal(true)
                expect(Base:Check({1, 2})).to.equal(true)
            end)

            it("should reject non-arrays", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check(nil)).to.equal(false)
                expect(Base:Check({Test = true})).to.equal(false)
            end)
        end)

        describe("OfLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should reject arrays greater than the specified length", function()
                expect(Base:OfLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:OfLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)
        end)

        describe("MinLength", function()
            it("should reject arrays shorter than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4})).to.equal(false)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays longer than the specified length", function()
                expect(Base:MinLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
                expect(Base:MinLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(true)
            end)
        end)

        describe("MaxLength", function()
            it("should reject arrays longer than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5, 6})).to.equal(false)
            end)

            it("should accept arrays equal to the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4, 5})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4, 5})).to.equal(true)
            end)

            it("should accept arrays shorter than the specified length", function()
                expect(Base:MaxLength(5):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:MaxLength(function()
                    return 5
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)
        end)

        describe("Contains", function()
            it("should accept arrays containing the specified element", function()
                expect(Base:Contains(1):Check({1, 2, 3, 4})).to.equal(true)
                expect(Base:Contains(function()
                    return 1
                end):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays not containing the specified element", function()
                expect(Base:Contains(1):Check({2, 3, 4})).to.equal(false)
                expect(Base:Contains(function()
                    return 1
                end):Check({2, 3, 4})).to.equal(false)
            end)
        end)

        describe("OfType", function()
            it("should accept arrays containing only the specified type", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject arrays containing elements of other types", function()
                expect(Base:OfType(TypeGuard.Number()):Check({1, "Test", 3, 4})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should throw for non TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({1})
                end).to.throw()

                expect(function()
                    Base:OfStructure({function() end})
                end).to.throw()

                expect(function()
                    Base:OfStructure({{}})
                end).to.throw()
            end)

            it("should not throw for TypeCheckers inside the template array", function()
                expect(function()
                    Base:OfStructure({TypeGuard.Number()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.String()})
                end).never.to.throw()

                expect(function()
                    Base:OfStructure({TypeGuard.Array()})
                end).never.to.throw()
            end)

            it("should accept arrays with additional contents", function()
                expect(Base:OfStructure({TypeGuard.Number(), TypeGuard.Number()}):Check({1, 2, 3})).to.equal(true)
            end)

            it("should accept an array of a correct type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, 3, 4})).to.equal(true)
            end)

            it("should reject an array of a incorrect type (numerical)", function()
                expect(Base:OfStructure({
                    TypeGuard.Number(), TypeGuard.Number(),
                    TypeGuard.Number(), TypeGuard.Number()
                }):Check({1, 2, "Test", 4})).to.equal(false)
            end)

            it("should check recursively", function()
                expect(Base:OfStructure({
                    [1] = Base:OfStructure({TypeGuard.String()});
                    [2] = Base:OfStructure({TypeGuard.Boolean()});
                }):Check({ {"Test"}, {true} })).to.equal(true)
            end)
        end)

        describe("StructuralEquals (Strict + OfStructure)", function()
            it("should reject arrays with additional contents", function()
                local Checker = Base:StructuralEquals({TypeGuard.Number(), TypeGuard.Number()})
                expect(Checker:Check({1, 2})).to.equal(true)
                expect(Checker:Check({1, 2, 3})).to.equal(false)
            end)
        end)
    end)

    describe("Nil", function()
        describe("Init", function()
            it("should accept nil", function()
                expect(TypeGuard.Nil():Check(nil)).to.equal(true)
            end)

            it("should reject non-nil", function()
                expect(TypeGuard.Nil():Check(1)).to.equal(false)
                expect(TypeGuard.Nil():Check(function() end)).to.equal(false)
                expect(TypeGuard.Nil():Check({})).to.equal(false)
                expect(TypeGuard.Nil():Check(false)).to.equal(false)
            end)
        end)
    end)

    describe("Enum", function()
        describe("Init", function()
            it("should throw given non-EnumItem, non-Enum values", function()
                expect(function()
                    TypeGuard.Enum(1)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum(true)
                end).to.throw()

                expect(function()
                    TypeGuard.Enum({})
                end).to.throw()
            end)

            it("should not throw given EnumItem or Enum (or function) values", function()
                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(Enum.AccessoryType.Shirt)
                end).never.to.throw()

                expect(function()
                    TypeGuard.Enum(function()
                        return Enum.AccessoryType.Shirt
                    end)
                end).never.to.throw()
            end)
        end)

        describe("IsA", function()
            it("should accept an Enum item if the respective EnumItem is a sub-item", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AccessoryType.Shirt)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AccessoryType.Shirt)).to.equal(true)
            end)

            it("should reject EnumItems which are not part of the Enum class", function()
                expect(TypeGuard.Enum(Enum.AccessoryType):Check(Enum.AlphaMode.Overlay)).to.equal(false)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType
                end):Check(Enum.AlphaMode.Overlay)).to.equal(false)
            end)

            it("should accept EnumItems which are equal", function()
                expect(TypeGuard.Enum(Enum.AccessoryType.Face):Check(Enum.AccessoryType.Face)).to.equal(true)
                expect(TypeGuard.Enum(function()
                    return Enum.AccessoryType.Face
                end):Check(Enum.AccessoryType.Face)).to.equal(true)
            end)
        end)
    end)

    describe("Thread", function()
        local Base = TypeGuard.Thread()

        describe("Init", function()
            it("should reject non-thread values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({})).to.equal(false)
            end)

            it("should accept thread values", function()
                expect(Base:Check(coroutine.create(function() end))).to.equal(true)
            end)
        end)

        describe("HasStatus", function()
            it("should accept running threads given 'running'", function()
                local Thread = coroutine.running()

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept suspended threads given 'suspended'", function()
                local Thread = task.spawn(function()
                    task.wait(1)
                end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(true)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(true)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
            end)

            it("should accept threads given 'dead'", function()
                local Thread = task.spawn(function() end)

                expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("normal"):Check(Thread)).to.equal(false)
                expect(Base:HasStatus("dead"):Check(Thread)).to.equal(true)

                expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(false)
                expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(true)
            end)

            it("should accept threads given 'normal'", function()
                local DidRun = false
                local TestCoroutine = coroutine.create(function(Callback)
                    Callback()
                end)

                task.spawn(function()
                    local Thread = coroutine.running()

                    task.spawn(TestCoroutine, function()
                        expect(Base:HasStatus("suspended"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("running"):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus("normal"):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus("dead"):Check(Thread)).to.equal(false)

                        expect(Base:HasStatus(function() return "suspended" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "running" end):Check(Thread)).to.equal(false)
                        expect(Base:HasStatus(function() return "normal" end):Check(Thread)).to.equal(true)
                        expect(Base:HasStatus(function() return "dead" end):Check(Thread)).to.equal(false)
                        DidRun = true
                    end)
                end)

                expect(DidRun).to.equal(true)
            end)
        end)
    end)

    describe("Object", function()
        local Base = TypeGuard.Object()

        describe("Init", function()
            it("should reject non-object values", function()
                expect(Base:Check(1)).to.equal(false)
                expect(Base:Check(function() end)).to.equal(false)
                expect(Base:Check({1})).to.equal(false)
            end)

            it("should accept object values", function()
                expect(Base:Check({})).to.equal(true)
                expect(Base:Check({Test = 123})).to.equal(true)
                expect(Base:Check({Test = false})).to.equal(true)
            end)
        end)

        describe("OfValueType", function()
            it("should accept an object with the given value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123})).to.equal(true)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different value type", function()
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test1 = 123, Test2 = "123"})).to.equal(false)
                expect(Base:OfValueType(TypeGuard.Number()):Check({Test = "123", Another = "987"})).to.equal(false)
            end)
        end)

        describe("OfKeyType", function()
            it("should accept an object with the given key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123})).to.equal(true)
                expect(Base:OfKeyType(TypeGuard.String()):Check({Test = 123, Another = 987})).to.equal(true)
            end)

            it("should reject an object with a different key type", function()
                expect(Base:OfKeyType(TypeGuard.String()):Check({[{}] = true})).to.equal(false)
                expect(Base:OfKeyType(TypeGuard.String()):Check({[Instance.new("Part")] = true})).to.equal(false)
            end)
        end)

        describe("OfStructure", function()
            it("should accept an object with the given structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should accept additional fields when not in strict mode", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(true)
            end)

            it("should recurse given sub object TypeCheckers", function()
                expect(Base:OfStructure({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true}})).to.equal(true)
            end)
        end)

        describe("StructuralEquals (OfStructure + Strict)", function()
            it("should accept an object with the given structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true})).to.equal(true)
            end)

            it("should reject an object with a different structure", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = "true"})).to.equal(false)
            end)

            it("should reject additional fields when not in strict mode", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Number(),
                    Another = TypeGuard.Boolean()
                }):Check({Test = 123, Another = true, Test2 = "123"})).to.equal(false)
            end)

            it("should recurse given sub object TypeCheckers but not enforce strict recursively", function()
                expect(Base:StructuralEquals({
                    Test = TypeGuard.Object({
                        Test = TypeGuard.Number(),
                        Another = TypeGuard.Boolean()
                    })
                }):Check({Test = {Test = 123, Another = true, Final = {}}})).to.equal(true)
            end)
        end)
    end)
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">376798fc9c6d206402b5dabd0002c09d</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Cleaner</string>
				<string name="ScriptGuid">{B0C86C03-49DE-4E2E-B6A4-0A809C031BDC}</string>
				<ProtectedString name="Source"><![CDATA[local TypeGuard = require(script.Parent:WaitForChild("TypeGuard"))

local ValidClass = TypeGuard.Object():OfStructure({
    __index = TypeGuard.Object();
    Destroy = TypeGuard.Function():Optional();
    new = TypeGuard.Function();
})

local CleanerType = TypeGuard.Object():OfStructure({
    Clean = TypeGuard.Function();
}):And(ValidClass)

local DestroyableType = TypeGuard.Object():OfStructure({
    Destroy = TypeGuard.Function();
})

local CustomSignalType = TypeGuard.Object():OfStructure({
    Disconnect = TypeGuard.Function();
})

local CustomMethodType = TypeGuard.Object():OfStructure({
    IsCustomMethod = TypeGuard.Boolean();
})

local CleanableType = TypeGuard.Instance()
                        :Or(TypeGuard.Function())
                        :Or(TypeGuard.Thread())
                        :Or(TypeGuard.RBXScriptConnection())
                        :Or(CleanerType:Equals(function(self)
                            return self -- Cleaners should not be able to Add() themselves because that would just cause recursion overflow
                        end):Negate())
                        :Or(DestroyableType)
                        :Or(CustomSignalType)
                        :Or(CustomMethodType)

local VALIDATE_METHOD_PARAMS = true
local VALIDATE_CLEANABLES = true

local ERR_CLASS_ALREADY_WRAPPED = "Class already wrapped"
local ERR_OBJECT_FINISHED = "Object lifecycle ended, but key %s was indexed"
local ERR_NO_OBJECT = "No object given"

local TYPE_SCRIPT_CONNECTION = "RBXScriptConnection"
local TYPE_INSTANCE = "Instance"
local TYPE_FUNCTION = "function"
local TYPE_THREAD = "thread"
local TYPE_TABLE = "table"

local OBJECT_FINALIZED_MT = {
    __index = function(_, Key)
        error(ERR_OBJECT_FINISHED:format(tostring(Key)))
    end;
}

--- New object & utility functions for handling the lifecycles of Lua objects, aims to help prevent memory leaks
local Cleaner = {}
Cleaner.__index = Cleaner
Cleaner._Supported = {}
Cleaner._Validators = {}
Cleaner._ObjectMethods = {"Disconnect", "Destroy", "Clean"}

Cleaner._Supported[TYPE_TABLE] = function(Item)
    for _, MethodName in ipairs(Cleaner._ObjectMethods) do
        if (Cleaner.IsLocked(Item)) then
            break
        end

        local Method = Item[MethodName]

        if (not Method) then
            continue
        end

        Method(Item)
    end

    -- Array of cleanables (can include other Cleaners)
    if (not Cleaner.IsLocked(Item) and Item[1]) then
        local NextCleaner = Cleaner.new()

        for _, Value in ipairs(Item) do
            NextCleaner:Add(Value)
        end

        NextCleaner:Clean()
    end
end

Cleaner._Supported[TYPE_THREAD] = function(Item)
    coroutine.close(Item)
end

Cleaner._Supported[TYPE_FUNCTION] = function(Item)
    Item()
end

Cleaner._Supported[TYPE_SCRIPT_CONNECTION] = function(Item)
    Item:Disconnect()
end

Cleaner._Supported[TYPE_INSTANCE] = function(Item)
    Item:Destroy()
end

function Cleaner.new()
    return setmetatable({
        _DidClean = false;
        _CleanList = {};
        _Index = 1;
    }, Cleaner)
end

local AddParams = TypeGuard.VariadicParamsWithContext(CleanableType)
--- Adds an object to this Cleaner. Object must be one of the following:
--- - Cleaner
--- - Function
--- - Coroutine / Thread
--- - Roblox Instance
--- - Roblox Event Connection
--- - Custom Method (via Cleaner.CustomMethod)
--- - Table containing one of the following methods:
---   - Object:Clean()
---   - Object:Destroy()
---   - Object:Disconnect()
function Cleaner:Add(...)
    if (VALIDATE_CLEANABLES) then
        AddParams(self, ...)
    end

    local CleanList = self._CleanList

    -- Verify types & push onto array
    local Size = select("#", ...)

    for Index = 1, Size do
        local Item = select(Index, ...)
        CleanList[self._Index] = Item
        self._Index += 1
    end

    -- Add after Clean called? Likely result of bad yielding, so clean up whatever is doing this.
    if (self._DidClean) then
        self:Clean()
    end

    return self
end
Cleaner.add = Cleaner.Add

--- Cleans and locks this Cleaner preventing it from being used again. If an object is added to the Cleaner after it has been locked, it will be cleaned immediately.
function Cleaner:Clean()
    local Supported = Cleaner._Supported
    local CleanList = self._CleanList

    for Index, Item in ipairs(CleanList) do
        task.spawn(Supported[typeof(Item)], Item)
        CleanList[Index] = nil
    end

    self._Index = 1
    self._DidClean = true
end
Cleaner.clean = Cleaner.Clean

--- Adds whatever coroutine called this method to the Cleaner
function Cleaner:AddContext()
    self:Add(coroutine.running())
end
Cleaner.addContext = Cleaner.AddContext

local function CleanerSpawn(self, Call, ...)
    self:AddContext()
    Call(...)
end

--- Spawns a coroutine & adds to the Cleaner
function Cleaner:Spawn(Callback, ...)
    task.spawn(CleanerSpawn, self, Callback, ...)
end
Cleaner.spawn = Cleaner.Spawn

local function CleanerDelay(Duration, Call, ...)
    task.wait(Duration)
    Call()
end

--- Delays a spawned coroutine & adds to cleaner
function Cleaner:Delay(Time, Callback, ...)
    self:Spawn(CleanerDelay, Time, Callback, ...)
end
Cleaner.delay = Cleaner.Delay

-- Standalone functions --

--- Permanently locks down an object once finished
function Cleaner.Lock(Object)
    assert(Object, ERR_NO_OBJECT)

    -- Have to "nil" everything to ensure the __index error works
    for Key in pairs(Object) do
        Object[Key] = nil
    end

    setmetatable(Object, OBJECT_FINALIZED_MT)
    table.freeze(Object)
end
if (VALIDATE_METHOD_PARAMS) then
    Cleaner.Lock = TypeGuard.WrapFunctionParams(Cleaner.Lock, TypeGuard.Object())
end
Cleaner.lock = Cleaner.Lock

--- Wraps the class to ensure more lifecycle safety, including auto-lock on Destroy
function Cleaner.Wrap(Class)
    assert(not Cleaner.IsWrapped(Class), ERR_CLASS_ALREADY_WRAPPED)

    -- Creation --
    local OriginalNew = Class.new

    Class.new = function(...)
        local Object = OriginalNew(...)
        Object.Cleaner = Object.Cleaner or Cleaner.new()
        return Object
    end

    -- Destruction --
    local OriginalDestroy = Class.Destroy

    Class.Destroy = function(self, ...)
        if (OriginalDestroy) then
            OriginalDestroy(self, ...)
        end

        Cleaner.Lock(self)
    end

    Class._CLEANER_WRAPPED = true

    return Class
end
if (VALIDATE_METHOD_PARAMS) then
    Cleaner.Wrap = TypeGuard.WrapFunctionParams(Cleaner.Wrap, ValidClass)
end
Cleaner.wrap = Cleaner.Wrap

--- Determines if a class is already wrapped
function Cleaner.IsWrapped(Class)
    return Class._CLEANER_WRAPPED ~= nil
end
if (VALIDATE_METHOD_PARAMS) then
    Cleaner.IsWrapped = TypeGuard.WrapFunctionParams(Cleaner.IsWrapped, ValidClass)
end
Cleaner.isWrapped = Cleaner.IsWrapped

-- Determines if an object is locked via the mechanism in Cleaner
function Cleaner.IsLocked(Object)
    return getmetatable(Object) == OBJECT_FINALIZED_MT
end
if (VALIDATE_METHOD_PARAMS) then
    Cleaner.IsLocked = TypeGuard.WrapFunctionParams(Cleaner.IsLocked, TypeGuard.Object())
end
Cleaner.isLocked = Cleaner.IsLocked

-- Creates an object which signals for a Cleaner to call an arbitrary method name with a set of params
function Cleaner.CustomMethod(Object, Name, ...)
    local Args = {...}

    return {
        IsCustomMethod = true;

        Destroy = function()
            Object[Name](Object, unpack(Args))
        end;
    };
end

return Cleaner]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f814</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">init.spec</string>
					<string name="ScriptGuid">{51527382-59DD-4ABB-80EA-FF4E73A88411}</string>
					<ProtectedString name="Source"><![CDATA[return function()
    local Cleaner = require(script.Parent)

    local function GetTestClass()
        local TestClass = {}
        TestClass.__index = TestClass

        function TestClass.new()
            return setmetatable({}, TestClass)
        end

        return TestClass
    end

    describe("Cleaner.new", function()
        it("should create a new Cleaner", function()
            expect(Cleaner.new()).never.to.equal(nil)
            expect(Cleaner.new()).to.be.a("table")
        end)
    end)

    describe("Cleaner.Add", function()
        it("should reject invalid objects", function()
            expect(function() -- Number
                Cleaner.new():Add(1)
            end).to.throw()

            expect(function() -- String
                Cleaner.new():Add("test")
            end).to.throw()

            expect(function() -- Empty/unsupported object
                Cleaner.new():Add({})
            end).to.throw()
        end)

        it("should accept only valid CleanableObjects", function()
            expect(function() -- Instance
                Cleaner.new():Add(Instance.new("Part"))
            end).never.to.throw()

            expect(function() -- Inbuilt Signal connection
                local Connection = game.ChildAdded:Connect(function() end)
                Cleaner.new():Add(Connection)
                Connection:Disconnect()
            end).never.to.throw()

            expect(function() -- Cleaner
                Cleaner.new():Add(Cleaner.new())
            end).never.to.throw()

            expect(function() -- Coroutine
                Cleaner.new():Add(coroutine.running())
            end).never.to.throw()

            expect(function() -- Function
                Cleaner.new():Add(function() end)
            end).never.to.throw()

            expect(function() -- Custom object
                Cleaner.new():Add({
                    Destroy = function() end;
                })
            end).never.to.throw()

            expect(function() -- Custom Signal implementation
                Cleaner.new():Add({
                    Disconnect = function() end;
                })
            end).never.to.throw()
        end)

        it("should accept multiple CleanableObjects as args", function()
            expect(function()
                Cleaner.new():Add({
                    Destroy = function() end;
                }, {
                    Disconnect = function() end;
                })
            end).never.to.throw()
        end)

        it("should reject when Cleaner is passed itself", function()
            local Test = Cleaner.new()

            expect(function()
                Test:Add(Test)
            end).to.throw()

            expect(function()
                Test:Add({Test})
            end).to.throw()

            expect(function()
                Test:Add({game, Test})
            end).to.throw()
        end)
    end)

    describe("Cleaner.Clean", function()
        it("should destroy Instances", function()
            local Part = Instance.new("Part")
            Part.Parent = game:GetService("Workspace")

            local Test = Cleaner.new()
            Test:Add(Part)
            Test:Clean()

            expect(Part.Parent).to.equal(nil)
        end)

        it("should clean up script signal connections", function()
            local Part = Instance.new("Part")
            local Activated = 0

            local Test = Cleaner.new()
            Test:Add(Part.ChildAdded:Connect(function()
                Activated += 1
            end))
            Instance.new("Part", Part)
            Test:Clean()
            Instance.new("Part", Part)

            expect(Activated).to.equal(1)
        end)

        it("should clean up other cleaners", function()
            local Cleaned = false

            local Test1 = Cleaner.new()
                local Test2 = Cleaner.new()
                Test2:Add(function()
                    Cleaned = true
                end)
            Test1:Add(Test2)
            Test1:Clean()

            expect(Cleaned).to.equal(true)
        end)

        it("should close coroutines", function()
            local Closed = true
            local Running

            task.spawn(function()
                Running = coroutine.running()
                task.wait()
                Closed = false
            end)

            local Test = Cleaner.new()
            Test:Add(Running)
            Test:Clean()

            task.wait()
            expect(Closed).to.equal(true)
        end)

        it("should run functions async", function()
            local Count = 0

            local Test = Cleaner.new()

            for _ = 1, 5 do
                Test:Add(function()
                    Count += 1
                end)
            end

            for _ = 1, 5 do
                Test:Add(function()
                    task.wait(1)
                    Count += 1
                end)
            end

            local Time = os.clock()
            Test:Clean()
            expect(os.clock() - Time).to.be.near(0, 1/1000)
            expect(Count).to.equal(5)
        end)

        it("should call Destroy on custom objects", function()
            local Test = Cleaner.new()
            local Destroyed = false

            Test:Add({
                Destroy = function()
                    Destroyed = true
                end;
            })

            expect(Destroyed).to.equal(false)
            Test:Clean()
            expect(Destroyed).to.equal(true)
        end)

        it("should call Disconnect on custom signals", function()
            local Test = Cleaner.new()
            local Disconnected = false

            Test:Add({
                Disconnect = function()
                    Disconnected = true
                end;
            })

            expect(Disconnected).to.equal(false)
            Test:Clean()
            expect(Disconnected).to.equal(true)
        end)

        it("should clean up with custom method support", function()
            local Test = Cleaner.new()
            local DidRun = false

            local Object = {
                Test = function(_, X, Y, Z)
                    expect(X).to.equal(1)
                    expect(Y).to.equal(2)
                    expect(Z).to.equal(3)

                    DidRun = true
                end
            }
            Test:Add(Test.CustomMethod(Object, "Test", 1, 2, 3))
            Test:Clean()

            expect(DidRun).to.equal(true)
        end)
    end)

    describe("Cleaner.Add, Cleaner.Clean", function()
        it("should automatically clean for items added after", function()
            local Test = Cleaner.new()
            local Count = 0

            Test:Add({
                Disconnect = function()
                    Count += 1
                end;
            })

            Test:Clean()

            Test:Add({
                Disconnect = function()
                    Count += 1
                end;
            })

            expect(Count).to.equal(2)
        end)
    end)

    describe("Cleaner.Spawn", function()
        it("should spawn a function async", function()
            local Complete = false

            Cleaner.new():Spawn(function()
                Complete = true
            end)

            expect(Complete).to.equal(true)
        end)

        it("should terminate the spawned coroutine when Clean is called", function()
            local Test = Cleaner.new()
            local Complete = false

            Test:Spawn(function()
                task.wait()
                Complete = true
            end)
            Test:Clean()

            task.wait()
            expect(Complete).to.equal(false)
        end)
    end)

    describe("Cleaner.Lock", function()
        it("should throw with no object given", function()
            expect(function()
                Cleaner.Lock()
            end).to.throw()
        end)

        it("should accept an object", function()
            expect(function()
                Cleaner.Lock({})
            end).never.to.throw()
        end)

        it("should disallow reads on an object", function()
            local Object = {
                X = 1;
            }

            Cleaner.Lock(Object)

            expect(function()
                local Temp1 = Object.X
            end).to.throw()

            expect(function()
                local Temp2 = Object.Y
            end).to.throw()
        end)

        it("should disallow writes on an object", function()
            local Object = {
                X = 1;
            }

            Cleaner.Lock(Object)

            expect(function()
                Object.X = 2
            end).to.throw()

            expect(function()
                Object.Y = 3
            end).to.throw()
        end)
    end)

    describe("Cleaner.Wrap", function()
        it("should throw with no class given", function()
            expect(function()
                Cleaner.Wrap()
            end).to.throw()
        end)

        it("should throw with an invalid class given", function()
            expect(function()
                Cleaner.Wrap({
                    new = function() end;
                })
            end).to.throw()

            expect(function()
                Cleaner.Wrap({
                    __index = {}
                })
            end).to.throw()
        end)

        it("should accept a valid class", function()
            local Test = GetTestClass()

            expect(function()
                Cleaner.Wrap(Test)
            end).never.to.throw()
        end)

        it("should lock a destroyed object down", function()
            local Test = GetTestClass()
            Cleaner.Wrap(Test)

            expect(function()
                local Temp = Test.X
            end).never.to.throw()

            expect(function()
                Test.Y = 1
            end).never.to.throw()

            Test:Destroy()

            expect(function()
                local Temp = Test.X
            end).to.throw()

            expect(function()
                Test.Y = 2
            end).to.throw()
        end)

        it("should prevent multiple wraps", function()
            local Test = GetTestClass()
            Cleaner.Wrap(Test)

            expect(function()
                Cleaner.Wrap(Test)
            end).to.throw()
        end)

        it("should work without Destroy being initially present", function()
            local Test1 = GetTestClass()
            Cleaner.Wrap(Test1)
            expect(Test1.Destroy).to.be.ok()

            local Test2 = GetTestClass()
            local Destroyed = false

            function Test2:Destroy()
                Destroyed = true
            end

            Cleaner.Wrap(Test2)
            Test2.new():Destroy()
            expect(Destroyed).to.equal(true)
        end)
    end)

    describe("Cleaner.Wrap, Cleaner.IsWrapped", function()
        it("should detect when a class is wrapped", function()
            local Test = GetTestClass()
            expect(Cleaner.IsWrapped(Test)).to.equal(false)
            Cleaner.Wrap(Test)
            expect(Cleaner.IsWrapped(Test)).to.equal(true)
        end)
    end)
end]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f815</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="TweenService" referent="RBX624E9DDA14914F9CAE0043C99B5F1E7F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f76c</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX1F1CC3CC5CCD4679917F5B40E7B1C187">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f76d</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX3B3AC2B3D24547059107A39491ED1306">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f76e</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBXDFC4888A37C24A0D87C94AB4A9139F00">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f819</UniqueId>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX032C43B785A74CB788D4C931DF331DD3">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="Enabled">true</bool>
				<string name="Name">ChatInputBarConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f81a</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX0A815CB11D084B74AB4F418AA494F0C7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f772</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX8ADEB949602E424E9EC1B66AFF46BED8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f774</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXE5DE85C8FC1B4F77A712EC513EA4C110">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f776</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBX494AD73251A845D7826D4EC46924AC01">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f777</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX70676006EBA441498B5479C7AAA7FDAC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f817</UniqueId>
			</Properties>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXBCCC865CE7F6479392994366644D8AE4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f818</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX35CF04952C994785BAF9B78534DAF994">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f778</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBXAA3FF9CFDF9D49C5B46E4F6B2F9B8EA8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f779</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBXD9A1C08FFAAF40A8A6004A20767F79B3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f77b</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX59D83C43D4B748CD9ABCEFB2F9623FE5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f77f</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX8597626FC3564B7AA448B5CAB9C470B3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f781</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX784ABCC852284A23ACF3133A37AB1367">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f782</UniqueId>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX435C83ADD6A94B888B521F90806323C2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f784</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXF20B272C891C4090B2E9E3FA2ED77F53">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f786</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX084269A246F84FEDB022189AEB5D8264">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002ccce</UniqueId>
				<string name="Value">{93D5DA4D-9868-42F5-A7B1-4B113125F016}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX317096B6B5F947E3BA6609B4F4F0E6E0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f787</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX3E95096642064AAB83D6ADB5445EB971">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f788</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBXD3540C52ED0F4B8ABFE3AE6704E53C77">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f789</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXFAD21465D9C04A8CB1DEE9BC88852065">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f793</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXD094E710431F4450B13D97C60E9213C2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f795</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXC72F0AF4BD494688B33AE89500AB497B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f797</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX00EDFCDC960044BA9676A321AB4DACEE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f798</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX97799E994D2E436194B9E0BED88752E3">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f799</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBXE4F7D2DAB9CA461F821AF373D0235281">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f79c</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX2FBF993F46F04DF3B79A2D1AB600ED5B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f79f</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBX790924684D964D0E8930E6CBEBB64074">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7a1</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerStorage" referent="RBX6F8E6540B87A44218035498694094254">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7a2</UniqueId>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX760DB518DA5F47F18AC37CC49EF3F44D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7a3</UniqueId>
		</Properties>
	</Item>
	<Item class="LuaWebService" referent="RBX92EB99D280C0463CA5B8A36030A781EE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7af</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX1CAD775B2A5248D08394B47ADEFFF397">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7b2</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBXA84EF970846A4A8FB9D70A27415EC99C">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7de</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX52C763AF18DE44D38A9D0D18861443A5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0001f7e1</UniqueId>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX7436852D9583437BBF11BA31F2AA93BA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b00025095</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBXE47AE68ABDA14C22884E60FA476E9E87">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002afc1</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX4F4A1DCD96914F84A0121B7C9FAAD5CE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002afdf</UniqueId>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBX8F9E17DBFE9D46AAA46F5D987EC1A7FA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002b236</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX68FF3D0FB6A44B4397E41A81A580E2E6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Enabled">true</bool>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002b390</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXA93D3ABF447F4996A42873138BA706C2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<bool name="Is30FpsThrottleEnabled">true</bool>
			<bool name="IsPhysicsEnvironmentalThrottled">true</bool>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">7193884f588bab2a02a87b5b0002c2c9</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>